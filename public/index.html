<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>×˜×¨×™×•×•BIO - ××©×—×§ ×˜×¨×™×•×•×™×” ×‘×‘×™×•×œ×•×’×™×”</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* --- General Styles --- */
      :root {
        --bg-color: #f5f7fa;
        --text-color: #2d3748;
        --card-bg: #ffffff;
        --card-border: #e2e8f0;
        --button-bg: #a3bffa;
        --button-hover-bg: #7f9cf5;
        --button-text: white;
        --input-bg: #e2e8f0;
        --input-border: #cbd5e0;
        --accent-color: #7f9cf5;
        --success-color: #48bb78;
        --danger-color: #f56565;
        --link-color: #5a67d8;
        --disabled-bg: #cbd5e0;
        --disabled-text: #a0aec0;
        --toast-light-bg: #2d3748;
        --toast-light-text: white;
        --toast-dark-bg: #e2e8f0;
        --toast-dark-text: #2d3748;
        --lifeline-counter-bg: #5a67d8;
        --lifeline-counter-text: white;
      }

      body.dark-mode {
        --bg-color: #1a202c;
        --text-color: #e2e8f0;
        --card-bg: #2d3748;
        --card-border: #4a5568;
        --button-bg: #4a5568;
        --button-hover-bg: #2d3748;
        --button-text: #e2e8f0;
        --input-bg: #4a5568;
        --input-border: #718096;
        --accent-color: #63b3ed;
        --success-color: #68d391;
        --danger-color: #fc8181;
        --link-color: #63b3ed;
        --disabled-bg: #4a5568;
        --disabled-text: #718096;
        --toast-light-bg: #e2e8f0;
        --toast-light-text: #2d3748;
        --toast-dark-bg: #2d3748;
        --toast-dark-text: white;
        --lifeline-counter-bg: #4299e1;
        --lifeline-counter-text: #1a202c;
      }

      body {
        font-family: "Noto Sans Hebrew", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 0;
        transition: background-color 0.3s, color 0.3s;
        display: grid;
        grid-template-rows: auto 1fr auto;
        min-height: 100svh;
        position: relative;
      }

      .container {
        max-width: 800px;
        margin: 10px auto;
        padding: 10px;
        text-align: center;
        width: 100%;
        box-sizing: border-box;
        grid-row: 2 / 3;
      }
      header {
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        margin-bottom: 5px;
        padding: 10px 0;
        grid-row: 1 / 2;
        width: 100%;
      }
      h1 {
        font-size: 2rem;
        margin: 0;
      }
      .switch {
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        display: inline-block;
        width: 60px;
        height: 34px;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 34px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 5px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: var(--accent-color); /* Use variable */
      }
      input:checked + .slider:before {
        transform: translateX(26px);
      }
      .theme-icon {
        width: 20px;
        height: 20px;
        transition: opacity 0.4s;
      }
      .sun {
        opacity: 1;
      }
      .moon {
        opacity: 0;
      }
      input:checked + .slider .sun {
        opacity: 0;
      }
      input:checked + .slider .moon {
        opacity: 1;
      }
      #cumulative-score-container {
        position: absolute;
        left: 15px;
        top: 50%;
        transform: translateY(-50%);
        text-align: left;
      }
      #nickname-display {
        font-size: 0.9rem;
        font-weight: bold;
        color: #4a5568;
        cursor: pointer;
        transition: color 0.3s;
      }
      #nickname-display:hover {
        color: var(--accent-color); /* Use variable */
      }
      .dark-mode #nickname-display {
        color: #a0aec0;
      }
      .dark-mode #nickname-display:hover {
        color: var(--link-color); /* Use variable */
      }
      #cumulative-score-display {
        font-size: 0.8rem;
        color: #4a5568;
      }
      .dark-mode #cumulative-score-display {
        color: #a0aec0;
      }
      #start-screen {
        background: linear-gradient(135deg, #a3bffa, #e2e8f0);
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin: 10px 0;
      }
      .dark-mode #start-screen {
        background: linear-gradient(135deg, #2d3748, #1a202c);
      }
      #start-screen h2 {
        color: #2d3748;
        font-size: 1.5rem;
        margin: 10px 0;
      }
      .dark-mode #start-screen h2 {
        color: #e2e8f0;
      }
      #start-screen p {
        font-size: 1.1rem;
        line-height: 1.5;
        margin: 20px 0;
        color: #2d3748;
      }
      .dark-mode #start-screen p {
        color: #e2e8f0;
      }
      #start-screen-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      @media (max-width: 600px) {
        #start-screen-buttons {
          grid-template-columns: 1fr;
        }
      }
      .topic-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        padding: 10px 20px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.3s;
      }
      .topic-btn:hover {
        background-color: var(--button-hover-bg);
      }
      .question-count {
        font-size: 0.8rem;
        opacity: 0.8;
      }
      #game-screen,
      #result-screen {
        margin-top: 10px;
      }
      #status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 15px 0;
        height: 60px;
      }
      .status-circle-container {
        position: relative;
        width: 54px;
        height: 54px;
      }
      .status-circle-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
        font-size: 1rem;
      }
      .status-circle-bg {
        stroke: var(--input-bg); /* Use variable */
        transition: stroke 0.3s;
      }
      .status-circle-progress {
        transition: stroke-dashoffset 0.5s linear, stroke 0.5s linear;
        transform: rotate(-90deg);
        transform-origin: 50% 50%;
      }
      #timer-progress {
        stroke: var(--accent-color); /* Use variable */
      }
      #percentage-progress.green {
        stroke: var(--success-color); /* Use variable */
      }
      #percentage-progress.yellow {
        stroke: #ecc94b;
      }
      #percentage-progress.red {
        stroke: var(--danger-color); /* Use variable */
      }
      #question {
        font-size: 1.25rem;
        margin: 20px 0;
        line-height: 1.4;
      }
      .question-id-display {
        display: inline-block;
        font-size: 0.7rem;
        color: var(--disabled-text); /* Use variable */
        margin-right: 8px;
        opacity: 0.8;
        user-select: text;
        direction: ltr;
      }

      #answers {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .answer-btn {
        padding: 15px;
        text-align: center;
        font-size: 1rem;
        background-color: var(--input-bg); /* Use variable */
        color: var(--text-color); /* Use variable */
        border: none;
        border-radius: 15px;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s, visibility 0s,
          opacity 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        -webkit-tap-highlight-color: transparent;
      }
      .answer-btn:hover {
        background-color: var(--input-border); /* Use variable */
      }
      .answer-btn:active {
        transform: scale(0.95);
      }
      .correct {
        background-color: var(--success-color) !important; /* Use variable */
        color: white !important;
      }
      .wrong {
        background-color: var(--danger-color) !important; /* Use variable */
        color: white !important;
      }
      .answer-btn:focus {
        outline: none;
      }

      /* --- Lifeline Button Container --- */
      .lifeline-container {
          position: relative; /* Needed for absolute positioning of the counter */
          display: inline-block; /* Allows containers to sit side-by-side */
          margin: 0 5px; /* Spacing between buttons */
      }

      #game-buttons {
        margin: 25px 0;
      }

      /* --- Lifeline Button Styling --- */
      #game-buttons button.lifeline-btn {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background-color: var(--button-bg);
        color: var(--button-text);
        transition: background-color 0.3s, opacity 0.3s, transform 0.1s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        /* Removed margin from here, handled by container */
      }
      #game-buttons button.lifeline-btn:hover:not(:disabled) {
        background-color: var(--button-hover-bg);
        transform: translateY(-1px);
      }
      #game-buttons button.lifeline-btn:active:not(:disabled) {
        transform: scale(0.95);
        box-shadow: none;
      }
      #game-buttons button.lifeline-btn:disabled {
         background-color: var(--disabled-bg) !important;
         color: var(--disabled-text) !important;
         cursor: not-allowed;
         opacity: 0.7;
         box-shadow: none !important;
         transform: none !important;
      }

      /* --- Lifeline Counter Badge --- */
      .lifeline-counter {
          position: absolute;
          bottom: -5px; /* Position below the button */
          left: -5px; /* Position slightly to the left */
          background-color: var(--lifeline-counter-bg);
          color: var(--lifeline-counter-text);
          border-radius: 50%; /* Make it circular */
          width: 20px; /* Fixed size */
          height: 20px; /* Fixed size */
          font-size: 0.75rem; /* Smaller font size */
          font-weight: bold;
          display: flex;
          align-items: center;
          justify-content: center;
          line-height: 1; /* Ensure text is centered vertically */
          box-shadow: 0 1px 2px rgba(0,0,0,0.2);
          border: 1px solid rgba(255, 255, 255, 0.3); /* Subtle border */
          z-index: 1; /* Ensure it's above the button */
          transition: background-color 0.3s, color 0.3s, opacity 0.3s;
      }
      .lifeline-counter.hidden {
          opacity: 0; /* Hide when count is 0 */
          pointer-events: none; /* Prevent interaction when hidden */
      }


      .result-card {
        background-color: var(--card-bg); /* Use variable */
        padding: 12px 20px;
        margin: 10px 0;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        border: 1px solid var(--card-border); /* Use variable */
      }
      .progress-circle {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 60px;
        margin: 0 10px 10px 30px;
        vertical-align: middle;
      }
      #percentage-text-result {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
      }
      .highlight {
        color: var(--accent-color); /* Use variable */
        font-weight: bold;
      }

      /* --- Toast Styling (Uses Variables) --- */
      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--toast-light-bg); /* Use variable */
        color: var(--toast-light-text); /* Use variable */
        padding: 10px 20px;
        border-radius: 5px;
        opacity: 0;
        transition: opacity 0.5s;
        z-index: 1000;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      .toast.show {
        opacity: 1;
      }
      .dark-mode .toast {
        background-color: var(--toast-dark-bg); /* Use variable */
        color: var(--toast-dark-text); /* Use variable */
      }

      footer {
        margin-top: 20px;
        padding-bottom: 20px;
        font-size: 0.9rem;
        text-align: center;
        grid-row: 3 / 4;
      }
      footer a {
        color: var(--link-color); /* Use variable */
        text-decoration: none;
        margin: 0 2px;
      }
      .sequence-circle {
        width: 30px;
        height: 30px;
        line-height: 30px;
        border-radius: 50%;
        background-color: var(--input-bg); /* Use variable */
        border: 1px solid var(--input-border); /* Use variable */
        margin: 0 5px;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        font-size: 0.9rem;
        transition: background-color 0.3s, border-color 0.3s, color 0.3s;
        color: var(--text-color); /* Use variable */
      }
      .sequence-circle.correct {
        background-color: var(--success-color); /* Use variable */
        color: white;
        border-color: var(--success-color); /* Use variable */
      }
      .sequence-circle.wrong {
        background-color: var(--danger-color); /* Use variable */
        color: white;
        border-color: var(--danger-color); /* Use variable */
      }
      .sequence-circle.current {
        background-color: #ecc94b;
        color: #744210;
        font-weight: bold;
        border-color: #d69e2e;
      }
      .mistake-block {
        text-align: right;
        margin: 15px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid var(--card-border); /* Use variable */
      }
      .mistake-block:last-child {
        border-bottom: none;
      }
      .mistake-question {
        font-weight: bold;
        margin-bottom: 5px;
      }
      .wrong-answer {
        color: var(--danger-color); /* Use variable */
        margin-bottom: 3px;
      }
      .correct-answer {
        color: var(--success-color); /* Use variable */
      }
      .perfect {
        color: var(--success-color); /* Use variable */
        font-weight: bold;
        font-size: 1.1rem;
      }
      #tag-analysis {
        margin-top: 15px;
        line-height: 2;
        text-align: right;
      }
      .tag-cloud-item {
        display: inline-block;
        margin: 3px 4px;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.8rem;
        border: 1px solid;
        cursor: pointer;
        transition: transform 0.2s;
        white-space: nowrap;
        text-decoration: none;
      }
      .tag-cloud-item:hover {
        transform: translateY(-1px);
        text-decoration: none;
      }
      .tag-cloud-item:visited {
        color: inherit;
      }
      .result-buttons {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        gap: 15px;
      }
      .result-buttons button {
        padding: 10px 25px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: background-color 0.3s;
      }
      #share-result {
        background-color: var(--success-color); /* Use variable */
        color: white;
      }
      #share-result:hover {
        background-color: #38a169;
      }
      #restart {
        background-color: var(--accent-color); /* Use variable */
        color: white;
      }
      #restart:hover {
        background-color: var(--button-hover-bg); /* Use variable */
      }
      #result-progress-circle.green {
        stroke: var(--success-color); /* Use variable */
      }
      #result-progress-circle.yellow {
        stroke: #ecc94b;
      }
      #result-progress-circle.red {
        stroke: var(--danger-color); /* Use variable */
      }
      #result-progress-circle {
        transition: stroke-dashoffset 0.5s linear, stroke 0.5s linear;
      }
      #ranking ul,
      #overall-ranking ul {
        list-style: none;
        padding: 0;
        margin: 10px 0 0 0;
        text-align: right;
      }
      #ranking li,
      #overall-ranking li {
        padding: 5px 0;
        border-bottom: 1px dashed var(--card-border); /* Use variable */
        font-size: 0.9rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #ranking li:last-child,
      #overall-ranking li:last-child {
        border-bottom: none;
      }
      #ranking li.current-player,
      #overall-ranking li.current-player {
        font-weight: bold;
        color: var(--accent-color); /* Use variable */
      }
      #ranking .rank-score,
      #overall-ranking .rank-score {
        font-weight: bold;
        direction: ltr;
        margin-left: 10px;
      }
      #ranking .rank-number,
      #overall-ranking .rank-number {
        margin-right: 10px;
        color: var(--disabled-text); /* Use variable */
        min-width: 25px;
        text-align: center;
      }

      /* --- Score Popup Styling --- */
      .score-popup {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(72, 187, 120, 0.9);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 1.4rem;
        font-weight: bold;
        z-index: 1001;
        opacity: 0;
        transition: opacity 0.5s ease-out, transform 0.6s ease-out;
        pointer-events: none;
        /* --- Added for multi-line --- */
        white-space: pre-line;
        text-align: center;
        line-height: 1.3; /* Adjust line height */
      }
      .score-popup.show {
        opacity: 1;
        transform: translate(-50%, -50px);
      }
      .dark-mode .score-popup {
        background-color: rgba(104, 211, 145, 0.9);
      }
      /* --- Added for bonus text --- */
      .score-popup .bonus-text {
          display: block; /* Ensure it's on a new line */
          font-size: 0.9rem; /* Smaller font size for bonus */
          font-weight: normal; /* Normal weight for bonus */
          margin-top: 4px; /* Space between score and bonus */
      }
    </style>
  </head>
  <body>
    <script>
      // Set theme ASAP to prevent flash
      try {
          const savedDarkMode = localStorage.getItem("darkMode") === "true";
          if (savedDarkMode) {
              document.body.classList.add("dark-mode");
          }
      } catch (e) {
          console.error("Error accessing localStorage for theme:", e);
      }
    </script>
    <header>
      <h1>×˜×¨×™×•×•BIO</h1>
      <div id="cumulative-score-container">
        <div id="nickname-display">×˜×•×¢×Ÿ ×©×...</div>
        <div id="cumulative-score-display">×˜×•×¢×Ÿ × ×™×§×•×“...</div>
      </div>
      <label class="switch">
        <input type="checkbox" id="theme-toggle" />
        <span class="slider">
          <img
            src="https://img.icons8.com/ios-glyphs/30/ffffff/sun.png"
            alt="×©××©"
            class="theme-icon sun"
          />
          <img
            src="https://img.icons8.com/ios-glyphs/30/ffffff/moon-symbol.png"
            alt="×™×¨×—"
            class="theme-icon moon"
          />
        </span>
      </label>
    </header>
    <div class="container">
      <main>
        <div id="start-screen">
          <h2>××•×›×Ÿ ×œ×‘×—×•×¨ × ×•×©×?</h2>
          <p>
            ×”×“×¨×š ×”×›×™ ×˜×•×‘×” ×œ×œ××•×“ ×œ×‘×’×¨×•×ª ×‘×‘×™×•×œ×•×’×™×”? ×¤×©×•×˜ ×œ×©×—×§!
            <br />×›×›×œ ×©×ª×¢× ×• ×¢×œ ×™×•×ª×¨ ×©××œ×•×ª â€“ ×ª×‘×™× ×•, ×ª×–×›×¨×• ×•×ª× ×¦×—×• ××ª ×”×‘×—×™× ×”.
            <br />×˜×¨×™×•×•BIO ×”×•× ×”×“×¨×š ×”×›×™ ×›×™×¤×™×ª, ×—×›××” ×•×××•×§×“×ª ×œ×”×ª×›×•× ×Ÿ.
          </p>
          <div id="start-screen-buttons"></div>
        </div>
        <div id="game-screen" style="display: none">
          <div id="status-row">
            <div class="status-circle-container">
              <svg width="53.6" height="53.6" viewBox="0 0 53.6 53.6">
                <circle
                  class="status-circle-bg"
                  cx="26.8"
                  cy="26.8"
                  r="25.46"
                  stroke-width="2.68"
                  fill="none"
                />
                <circle
                  class="status-circle-progress"
                  id="timer-progress"
                  cx="26.8"
                  cy="26.8"
                  r="25.46"
                  stroke-width="2.68"
                  fill="none"
                  stroke-dasharray="159.84"
                  stroke-dashoffset="0"
                />
              </svg>
              <div class="status-circle-text" id="timer-text">120</div>
            </div>
            <div id="sequence-container"></div>
            <div class="status-circle-container">
              <svg width="53.6" height="53.6" viewBox="0 0 53.6 53.6">
                <circle
                  class="status-circle-bg"
                  cx="26.8"
                  cy="26.8"
                  r="25.46"
                  stroke-width="2.68"
                  fill="none"
                />
                <circle
                  class="status-circle-progress"
                  id="percentage-progress"
                  cx="26.8"
                  cy="26.8"
                  r="25.46"
                  stroke-width="2.68"
                  fill="none"
                  stroke-dasharray="159.84"
                  stroke-dashoffset="159.84"
                />
              </svg>
              <div class="status-circle-text" id="percentage-text-ingame">
                0%
              </div>
            </div>
          </div>
          <div id="question"></div>
          <div id="answers"></div>
          <div id="game-buttons">
            <div class="lifeline-container">
               <button id="fifty-fifty" class="lifeline-btn">50:50</button>
               <span id="fifty-fifty-counter" class="lifeline-counter">0</span>
            </div>
            <div class="lifeline-container">
               <button id="add-time" class="lifeline-btn">30+</button>
               <span id="add-time-counter" class="lifeline-counter">1</span> </div>
            <div class="lifeline-container">
               <button id="skip" class="lifeline-btn">×“×œ×’</button>
               <span id="skip-counter" class="lifeline-counter">0</span>
            </div>
          </div>
        </div>
        <div id="result-screen" style="display: none">
          <div class="result-card">
            <h3>ğŸ† ×ª×•×¦××•×ª ×”××©×—×§</h3>
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: space-around;
              "
            >
              <div>
                <p id="score"></p>
                <p id="accuracy-stats"></p>
              </div>
              <div class="progress-circle">
                <svg width="60" height="60" viewBox="0 0 60 60">
                  <circle
                    cx="30"
                    cy="30"
                    r="28"
                    stroke="#e2e8f0"
                    stroke-width="4"
                    fill="none"
                    class="status-circle-bg"
                  />
                  <circle
                    cx="30"
                    cy="30"
                    r="28"
                    stroke-width="4"
                    fill="none"
                    stroke-dasharray="175.9"
                    stroke-dashoffset="175.9"
                    id="result-progress-circle"
                    class="status-circle-progress"
                  />
                </svg>
                <span id="percentage-text-result">%</span>
              </div>
            </div>
          </div>
          <div class="result-card">
             <h3>âš™ï¸ ×’×œ×’×œ×™ ×”×¦×œ×” ×‘×©×™××•×©</h3>
            <p id="tools-used"></p> </div>
          <div class="result-card">
            <h3>ğŸ“Š ×“×™×¨×•×’ ×™×•××™ (×œ×¤×™ ×ª×©×•×‘×•×ª × ×›×•× ×•×ª)</h3>
            <div id="ranking">×˜×•×¢×Ÿ ×“×™×¨×•×’ ×™×•××™...</div>
          </div>
          <div class="result-card">
            <h3>ğŸ’ ×”×™×›×œ ×”×ª×”×™×œ×” (Top 10 ×œ×¤×™ × ×™×§×•×“)</h3>
            <div id="overall-ranking">×˜×•×¢×Ÿ ×“×™×¨×•×’ ×›×œ×œ×™...</div>
          </div>
          <div class="result-card">
            <h3>ğŸ“š ×˜×¢×™×ª? ×œ××“×ª!</h3>
            <div id="mistakes"></div>
          </div>
          <div class="result-card">
            <h3>ğŸ·ï¸ ×ª×’×™×•×ª</h3>
            <p>×œ×—×¥ ×¢×œ ×ª×’×™×ª ×›×“×™ ×œ×‘×¦×¢ ×—×™×¤×•×© ×‘×’×•×’×œ.</p>
            <div id="tag-analysis"></div>
          </div>
          <div class="result-buttons">
            <button id="share-result">×©×ª×£ ×ª×•×¦××”</button>
            <button id="restart">×©×—×§ ×©×•×‘</button>
          </div>
        </div>
      </main>
    </div>
    <footer>
      ×¤×•×ª×— ×¢×œ ×™×“×™ ××¨×™××œ ×<a
        href="https://galilbio.wordpress.com"
        target="_blank"
        >×”Ö·×‘Ö¼Ö´×™Ö¼×•Ö¹×œ×•Ö¹×’Ö´×™× ×©×œ ×’×œ×™×œ</a
      >
      ×‘×¢×–×¨×ª<a href="https://grok.com/" target="_blank">×’×¨×•×§</a>,<a
        href="https://chatgpt.com/"
        target="_blank"
        >Chat GPT</a
      >×•×’×<a href="https://gemini.google.com/app" target="_blank">Gemini</a> |
      <a href="admin.html" target="_blank">× ×™×”×•×œ</a>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
      // Wrap entire script logic in a try-catch block for better error reporting
      try {
          console.log("Script loaded and running");

          // --- Constants and Config ---
          const topicNames = { "human-body": "×’×•×£ ×”××“×", cell: "×”×ª×", ecology: "××§×•×œ×•×’×™×”", mix: "×¢×¨×‘×‘ ××•×ª×™", };
          const firebaseConfig = { apiKey: "AIzaSyAGFC_TB8iEMvS2PyxeASj1HH4i66AW4UA", authDomain: "trivbio.firebaseapp.com", projectId: "trivbio", storageBucket: "trivbio.firebasestorage.app", messagingSenderId: "1097087574583", appId: "1:1097087574583:web:b36c0441537a1f596215b2", measurementId: "G-ZY245YB23E", };
          const CIRCLE_CIRCUMFERENCE = 159.84;
          const RESULT_CIRCLE_CIRCUMFERENCE = 175.9;
          const BASE_SCORE_PER_QUESTION = 10;
          const STREAK_BONUS_MULTIPLIER = 2;
          // --- Initial Lifeline Counts ---
          const INITIAL_SKIP_COUNT = 4;
          const INITIAL_FIFTY_FIFTY_COUNT = 2;
          const INITIAL_ADD_TIME_COUNT = 1; // Now relevant for counter display
          // --- NEW: Streak and Bonus Constants ---
          const STREAK_THRESHOLD = 3; // Number of correct answers for streak bonus chance
          const LIFELINE_BONUS_CHANCE = 0.20; // 20% chance to get *any* lifeline bonus on streak
          const SKIP_BONUS_PROBABILITY = 0.60; // 60% of the bonus chance (12% overall)
          const FIFTY_FIFTY_BONUS_PROBABILITY = 0.25; // 25% of the bonus chance (5% overall)
          // Add Time bonus probability is the remainder (15% or 3% overall)
          const streakEmojis = ['ğŸ”¥', 'âœ¨', 'ğŸ‰', 'ğŸš€', 'ğŸ’ª', 'ğŸ’¯'];
          const lifelineBonusEmojis = ['ğŸ', 'ğŸ’¡', 'â­'];


          // --- Firebase Initialization ---
          let database;
          let auth; // <--- Added auth variable
          try {
              firebase.initializeApp(firebaseConfig);
              database = firebase.database();
              auth = firebase.auth(); // <--- Initialize auth
              console.log("Firebase initialized successfully");
          } catch (e) {
              console.error("FATAL: Firebase initialization failed!", e);
              document.body.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">×©×’×™××” ×§×¨×™×˜×™×ª ×‘×˜×¢×™× ×ª Firebase. ×œ× × ×™×ª×Ÿ ×œ×”××©×™×š.</div>';
              throw e; // Re-throw to stop script execution here
          }

          // --- DOM Elements ---
          // Declare all element variables here
          let startScreen, gameScreen, resultScreen, startScreenButtonsContainer, timerTextElement, timerProgressElement, percentageTextIngameElement, percentageProgressElement, questionElement, answersElement, fiftyFiftyButton, addTimeButton, skipButton, restartButton, themeToggle, toolsUsedElement, mistakesElement, sequenceContainer, tagAnalysisElement, resultProgressCircleElement, percentageTextResultElement, scoreElement, accuracyStatsElement, cumulativeScoreDisplayElement, nicknameDisplayElement, rankingElement, overallRankingElement, shareButton, skipCounterElement, fiftyFiftyCounterElement, addTimeCounterElement; // Added addTimeCounterElement

          // Function to get references to DOM elements
          function initializeDOMElements() {
              // Assign elements inside this function, called after DOM loaded
              startScreen = document.getElementById("start-screen");
              gameScreen = document.getElementById("game-screen");
              resultScreen = document.getElementById("result-screen");
              startScreenButtonsContainer = document.getElementById("start-screen-buttons");
              timerTextElement = document.getElementById("timer-text");
              timerProgressElement = document.getElementById("timer-progress");
              percentageTextIngameElement = document.getElementById("percentage-text-ingame");
              percentageProgressElement = document.getElementById("percentage-progress");
              questionElement = document.getElementById("question");
              answersElement = document.getElementById("answers");
              fiftyFiftyButton = document.getElementById("fifty-fifty");
              addTimeButton = document.getElementById("add-time");
              skipButton = document.getElementById("skip");
              restartButton = document.getElementById("restart");
              themeToggle = document.getElementById("theme-toggle");
              toolsUsedElement = document.getElementById("tools-used");
              mistakesElement = document.getElementById("mistakes");
              sequenceContainer = document.getElementById("sequence-container");
              tagAnalysisElement = document.getElementById("tag-analysis");
              resultProgressCircleElement = document.getElementById("result-progress-circle");
              percentageTextResultElement = document.getElementById("percentage-text-result");
              scoreElement = document.getElementById("score");
              accuracyStatsElement = document.getElementById("accuracy-stats");
              cumulativeScoreDisplayElement = document.getElementById("cumulative-score-display");
              nicknameDisplayElement = document.getElementById("nickname-display");
              rankingElement = document.getElementById("ranking");
              overallRankingElement = document.getElementById("overall-ranking");
              shareButton = document.getElementById("share-result");
              // --- Get counter elements ---
              skipCounterElement = document.getElementById("skip-counter");
              fiftyFiftyCounterElement = document.getElementById("fifty-fifty-counter");
              addTimeCounterElement = document.getElementById("add-time-counter"); // Get new counter element

              // Check critical elements
              const criticalElements = [startScreen, gameScreen, resultScreen, startScreenButtonsContainer, timerTextElement, timerProgressElement, percentageTextIngameElement, percentageProgressElement, questionElement, answersElement, fiftyFiftyButton, addTimeButton, skipButton, restartButton, themeToggle, toolsUsedElement, mistakesElement, sequenceContainer, tagAnalysisElement, resultProgressCircleElement, percentageTextResultElement, scoreElement, accuracyStatsElement, cumulativeScoreDisplayElement, nicknameDisplayElement, rankingElement, overallRankingElement, shareButton, skipCounterElement, fiftyFiftyCounterElement, addTimeCounterElement]; // Added addTimeCounterElement
              const missingElement = criticalElements.find(el => !el);
              if (missingElement) {
                  // Try to get the ID of the missing element for better debugging
                  const missingId = criticalElements.reduce((acc, el, index) => {
                      if (!el && !acc) {
                          // Infer ID based on variable name (this is fragile)
                          const ids = ["start-screen", "game-screen", "result-screen", "start-screen-buttons", "timer-text", "timer-progress", "percentage-text-ingame", "percentage-progress", "question", "answers", "fifty-fifty", "add-time", "skip", "restart", "theme-toggle", "tools-used", "mistakes", "sequence-container", "tag-analysis", "result-progress-circle", "percentage-text-result", "score", "accuracy-stats", "cumulative-score-display", "nickname-display", "ranking", "overall-ranking", "share-result", "skip-counter", "fifty-fifty-counter", "add-time-counter"]; // Added add-time-counter
                          return ids[index] || 'unknown';
                      }
                      return acc;
                  }, null);
                  throw new Error(`DOM element not found: #${missingId || 'unknown'}`);
              }
              console.log("DOM elements retrieved successfully.");
              return true; // Indicate success
          }


          // --- Game State Variables ---
          let currentTopic = "";
          let allQuestions = [];
          let questions = [];
          let currentQuestionIndex = 0;
          let currentQuestion = null;
          let correctCount = 0;
          let wrongCount = 0;
          let timerValue = 120;
          let totalTime = 120;
          let timerInterval;
          // --- Lifeline state ---
          let fiftyFiftyUsedCount = 0; // Track usage *within* the current game
          let addTimeUsed = false;    // Track usage *within* the current game
          let skipUsedCount = 0;      // Track usage *within* the current game
          let availableSkips = INITIAL_SKIP_COUNT; // Persistent count
          let availableFiftyFifty = INITIAL_FIFTY_FIFTY_COUNT; // Persistent count
          // --- END ---
          let mistakeDetails = [];
          let mistakenQuestions = [];
          let answerSequence = [];
          let answeredCorrectly = [];
          let gameTagStats = {};
          let currentStreak = 0;
          let longestStreak = 0;
          let playerId = null; // <--- Initialized to null
          let isUserAnonymous = true; // <--- Added flag
          let timerExpired = false;
          let gameActive = false;
          let currentGameScore = 0;
          let cumulativePlayerScore = 0;
          let playerNickname = "";

// ×—×™×•×ª ×–×›×¨×™× - ××•×›×¨×™× ×™×•×ª×¨, ×¢× × ×’×™×¢×•×ª ××¢× ×™×™× ×•×ª
const animalsMale = [
        // ×§×œ××¡×™×™× ×•××•×›×¨×™×
        "××¨×™×”", "× ××¨", "×¤×™×œ", "×–××‘", "×“×•×‘", "×©×•×¢×œ", "×¦×‘×™", "×¡×•×¡", "× ×©×¨", "×™× ×©×•×£", "×§×•×£", "×’××œ", "×ª× ×™×Ÿ", "×¦×‘", "×§×¨× ×£", "×”×™×¤×•×¤×•×˜×", "×™×’×•××¨", "×‘×¨×“×œ×¡",
        // ×™××™×™× ××•×›×¨×™×
        "×“×•×œ×¤×™×Ÿ", "×œ×•×•×™×ª×Ÿ", "×¤×™× ×’×•×•×™×Ÿ", "×›×œ×‘ ×™×", "××¨×™×” ×™×", "×›×¨×™×©", // ×›×¨×™×© ×”×•× ××•×›×¨, ×œ××¨×•×ª ×©×œ× ×ª××™×“ × ×ª×¤×¡ "×—×™×•×‘×™" ×§×œ××¡×™
        // ××•×›×¨×™× × ×•×¡×¤×™× ×•××¢×˜ ××™×•×—×“×™×
        "×’×•×¨×™×œ×”", "×©×™××¤× ×–×”", "×¤× ×“×”", "×§×•××œ×”", "×“×‘×™×‘×•×Ÿ", "×‘×•× ×”", "××™×™×œ", "×™×¢×œ", "×¤×œ××™× ×’×•", "×ª×•×›×™", "××œ×¤×§×”", "×œ××•×¨", "×¢×¦×œ×Ÿ", "×’×™×‘×•×Ÿ", "×“×¨×§×•×Ÿ ×§×•××•×“×•"
      ]; // ×¡×”"×›: 39

      // ×—×™×•×ª × ×§×‘×•×ª - ××§×‘×™×œ×•×ª ×•××•×›×¨×•×ª
      const animalsFemale = [
        // ××§×‘×™×œ×•×ª ×œ×–×›×¨×™× + ××•×›×¨×•×ª ×××•×“
        "×œ×‘×™××”", "× ××¨×”", "×¤×™×œ×”", "×–××‘×”", "×“×•×‘×”", "×©×•×¢×œ×”", "×¦×‘×™×”", "×¡×•×¡×”", "×™× ×©×•×¤×”", "×§×•×¤×”", "×’××œ×”", "×ª× ×™× ×”", "×¦×‘×”", "×§×¨× ×¤×™×ª", // × ×§×‘×ª ×§×¨× ×£, ×¤×—×•×ª × ×¤×•×¥ ××š ×§×™×™×
        "×“×•×œ×¤×™× ×”", "×¤×™× ×’×•×•×™× ×™×ª", // × ×§×‘×ª ×¤×™× ×’×•×•×™×Ÿ, ×¤×—×•×ª × ×¤×•×¥ ××š ×§×™×™×
        "×›×œ×‘×ª ×™×", "×œ×‘×™××ª ×™×",
        "×’×•×¨×™×œ×”", "×©×™××¤× ×–×”", "×¤× ×“×”", "×§×•××œ×”", "×“×‘×™×‘×•× ×™×ª", "×‘×•× ×”", // ×‘×•× ×” × ×—×©×‘ ×’× × ×§×‘×” ×œ×¢×™×ª×™× ×§×¨×•×‘×•×ª
        "××™×™×œ×”", "×™×¢×œ×”", "×¤×œ××™× ×’×•", // ×¤×œ××™× ×’×• ××©××© ×œ×©× ×™ ×”××™× ×™×
        "×ª×•×›×™×ª", "××œ×¤×§×”", "×œ××•×¨", // ×œ××•×¨ ××©××© ×œ×¢×™×ª×™× ×œ×©× ×™ ×”××™× ×™×
        "×¢×¦×œ× ×™×ª", "×’'×™×¨×¤×”",
        // ×—×™×•×ª × ×§×‘×” ××•×›×¨×•×ª × ×•×¡×¤×•×ª
        "×—×ª×•×œ×”", "×›×œ×‘×”", "×¤×¨×”", "×›×‘×©×”", "×¦×™×¤×•×¨", "× ××œ×”", "×“×‘×•×¨×”", "×¤×¨×¤×¨×™×ª", "×™×¢× ×”"
      ]; // ×¡×”"×›: 42

      // ×ª×›×•× ×•×ª ×–×›×¨×™× - ×—×™×•×‘×™×•×ª ×•×××•×§×“×•×ª
      const attributesMale = [
        "×××™×¥", "×—×›×", "××”×™×¨", "×©×§×˜", "×—×–×§", "×¡×§×¨×Ÿ", "× ×××Ÿ",
        "×¤×™×§×—", "× ×‘×•×Ÿ", "×œ××“×Ÿ", "××ª××™×“", "× ×—×•×©", "×—×¨×•×¥", "×©×§×“×Ÿ", "××™×ª×Ÿ",
        "×—×§×¨×Ÿ", "××ª×¢× ×™×™×Ÿ", "×¤×ª×•×—", "×™×¦×™×¨×ª×™", "×× ×”×™×’", "××“×™×‘", "×¨×’×•×¢",
        "×××•×§×“", "××’×Ÿ", "××™×•×—×“", "×–×•×”×¨", "×©××—", "×× ×¨×’×˜×™", "× ×œ×”×‘",
        "××•×¤×˜×™××™", "×—×™×•× ×™", "×ª×•×¡×¡", "×–×¨×™×–", "××‘×™×Ÿ", "×‘×¢×œ ×ª×•×‘× ×”", "××¢×•×¨×¨ ×”×©×¨××”"
      ]; // ×¡×”"×›: 36

      // ×ª×›×•× ×•×ª × ×§×‘×•×ª - ×—×™×•×‘×™×•×ª ×•×××•×§×“×•×ª
      const attributesFemale = [
        "×××™×¦×”", "×—×›××”", "××”×™×¨×”", "×©×§×˜×”", "×—×–×§×”", "×¡×§×¨× ×™×ª", "× ××× ×”",
        "×¤×™×§×—×™×ª", "× ×‘×•× ×”", "×œ××“× ×™×ª", "××ª××™×“×”", "× ×—×•×©×”", "×—×¨×•×¦×”", "×©×§×“× ×™×ª", "××™×ª× ×”",
        "×—×§×¨× ×™×ª", "××ª×¢× ×™×™× ×ª", "×¤×ª×•×—×”", "×™×¦×™×¨×ª×™×ª", "×× ×”×™×’×”", "××“×™×‘×”", "×¨×’×•×¢×”",
        "×××•×§×“×ª", "××’× ×”", "××™×•×—×“×ª", "×–×•×”×¨×ª", "×©××—×”", "×× ×¨×’×˜×™×ª", "× ×œ×”×‘×ª",
        "××•×¤×˜×™××™×ª", "×—×™×•× ×™×ª", "×ª×•×¡×¡×ª", "×–×¨×™×–×”", "××‘×™× ×”", "×‘×¢×œ×ª ×ª×•×‘× ×”", "××¢×•×¨×¨×ª ×”×©×¨××”"
      ]; // ×¡×”"×›: 36

          function generateRandomUsername() {
            const isMale = Math.random() < 0.5;
            const animals = isMale ? animalsMale : animalsFemale;
            const animal = animals[Math.floor(Math.random() * animals.length)];
            const attributes = isMale ? attributesMale : attributesFemale;
            const attribute = attributes[Math.floor(Math.random() * attributes.length)];
            return `${animal} ${attribute}`;
          }

          // --- UI Update Functions ---
          function populateTopicButtons(questionCounts) {
              if (!startScreenButtonsContainer) {
                  console.error("Cannot populate topic buttons: container not found.");
                  return;
              }
              const topics = [
                  { id: "human-body", name: "×’×•×£ ×”××“×", emoji: "ğŸ§" },
                  { id: "cell", name: "×”×ª×", emoji: "ğŸ§¬" },
                  { id: "ecology", name: "××§×•×œ×•×’×™×”", emoji: "ğŸŒ" },
                  { id: "mix", name: "×¢×¨×‘×‘ ××•×ª×™", emoji: "ğŸ²" },
              ];

              startScreenButtonsContainer.innerHTML = ""; // Clear existing buttons
              topics.forEach((topic) => {
                  const button = document.createElement("button");
                  button.classList.add("topic-btn");
                  button.dataset.topic = topic.id;
                  // Safely get count, defaulting to 0
                  const count = (questionCounts && typeof questionCounts[topic.id] === 'number') ? questionCounts[topic.id] : 0;
                  button.innerHTML = `${topic.name} <span>${topic.emoji}</span> <span class="question-count">[${count} ×©××œ×•×ª]</span>`;
                  button.addEventListener("click", async () => {
                      vibrate(50);
                      currentTopic = button.getAttribute("data-topic");
                      await loadQuestionsForTopic(currentTopic);
                  });
                  startScreenButtonsContainer.appendChild(button);
              });
          }

          function showToast(message, duration = 3000) {
              // Remove existing toasts first
              document.querySelectorAll(".toast").forEach((t) => t.remove());

              const toast = document.createElement("div");
              toast.classList.add("toast");
              toast.textContent = message;
              document.body.appendChild(toast);

              // Trigger reflow to enable animation
              toast.offsetHeight;

              toast.classList.add("show");

              if (duration > 0) {
                  setTimeout(() => {
                      toast.classList.remove("show");
                      // Remove element after fade out animation completes
                      setTimeout(() => toast.remove(), 500);
                  }, duration);
              }
          }

          function updateCumulativeScoreDisplay() {
              if (cumulativeScoreDisplayElement) {
                  cumulativeScoreDisplayElement.textContent = `× ×™×§×•×“ ×›×œ×œ×™: ${cumulativePlayerScore.toLocaleString()}`;
              } else {
                  console.error("Cumulative score display element not found.");
              }
          }

          function updateNicknameDisplay() {
              if (nicknameDisplayElement) {
                  nicknameDisplayElement.textContent = playerNickname;
                  // Ensure listener is attached only once or re-attached safely
                  nicknameDisplayElement.removeEventListener("click", editNickname);
                  nicknameDisplayElement.addEventListener("click", editNickname);
              } else {
                  console.error("Nickname display element not found.");
              }
          }

          function setTheme(isDarkMode) {
              document.body.classList.toggle("dark-mode", isDarkMode);
              // Update timer color based on theme and value
              if (timerProgressElement) {
                  if (timerValue <= 30) {
                      timerProgressElement.style.stroke = "var(--danger-color)"; // Red when low
                  } else {
                      timerProgressElement.style.stroke = "var(--accent-color)";
                  }
              }
              // Update other elements if needed
          }

          // --- Update Lifeline Counters ---
          function updateLifelineCounters() {
              if (skipCounterElement) {
                  skipCounterElement.textContent = availableSkips;
                  skipCounterElement.classList.toggle('hidden', availableSkips <= 0);
              }
              if (fiftyFiftyCounterElement) {
                  fiftyFiftyCounterElement.textContent = availableFiftyFifty;
                  fiftyFiftyCounterElement.classList.toggle('hidden', availableFiftyFifty <= 0);
              }
              // --- Update Add Time Counter ---
              if (addTimeCounterElement) {
                  addTimeCounterElement.textContent = addTimeUsed ? '0' : '1'; // Show 1 if not used, 0 if used
                  addTimeCounterElement.classList.toggle('hidden', addTimeUsed); // Hide if used
              }
              // --- END ---

              // Disable buttons based on availability and game state
              if (skipButton) skipButton.disabled = (availableSkips <= 0 || timerExpired || !gameActive);
              if (fiftyFiftyButton) fiftyFiftyButton.disabled = (availableFiftyFifty <= 0 || timerExpired || !gameActive);
              if (addTimeButton) addTimeButton.disabled = (addTimeUsed || timerExpired || !gameActive);
          }


          // --- Authentication Logic (NEW) ---
          function setupAuthentication() {
              if (!auth) {
                  console.error("Firebase Auth object not initialized!");
                  showToast("×©×’×™××ª ××™××•×ª ×§×¨×™×˜×™×ª!");
                  return;
              }
              auth.onAuthStateChanged(user => {
                  if (user) {
                      // User is signed in (could be Google from admin or Anonymous)
                      playerId = user.uid;
                      isUserAnonymous = user.isAnonymous; // Check if it's an anonymous user
                      console.log(`Auth state changed: User found. ID: ${playerId}, Anonymous: ${isUserAnonymous}`);
                      initializePlayerState(); // Initialize with the current user's ID
                  } else {
                      // No user is signed in. Attempt anonymous sign-in as fallback.
                      console.log("Auth state changed: No user found. Attempting anonymous sign-in.");
                      auth.signInAnonymously()
                          .then((userCredential) => {
                              // Listener will fire again with the new anonymous user,
                              // so initializePlayerState will be called then.
                              console.log("Anonymous sign-in successful. Waiting for state change.");
                          })
                          .catch((error) => {
                              console.error("Fallback anonymous sign-in failed:", error);
                              showToast("×©×’×™××” ×§×¨×™×˜×™×ª ×‘×”×ª×—×‘×¨×•×ª. × ×¡×” ×œ×¨×¢× ×Ÿ.");
                              // Display error state in UI
                              if(cumulativeScoreDisplayElement) cumulativeScoreDisplayElement.textContent = "×©×’×™××ª ×”×ª×—×‘×¨×•×ª";
                              if(nicknameDisplayElement) nicknameDisplayElement.textContent = "×©×’×™××ª ×”×ª×—×‘×¨×•×ª";
                          });
                  }
              });
          }


          // --- Initialization and Main Logic (MODIFIED) ---
          function mainAppLogic() {
              if (!database || !auth) { // <--- Check for auth object too
                  console.error("Database or Auth not initialized. Cannot run main logic.");
                  showToast("×©×’×™××” ×§×¨×™×˜×™×ª: ××™×Ÿ ×—×™×‘×•×¨ ×œ××¡×“ ×”× ×ª×•× ×™× ××• ××™××•×ª.");
                  return;
              }

              // Initialize question counts and populate buttons
              (async function initializeQuestionCounts() {
                  let cachedCounts = {};
                  let cachedTimestamp = null;
                  const defaultCounts = { "human-body": 0, cell: 0, ecology: 0, mix: 0 };
                  try {
                      cachedCounts = JSON.parse(localStorage.getItem("questionCounts") || "{}");
                      // Ensure all keys exist and are numbers
                      Object.keys(defaultCounts).forEach(key => {
                          if (typeof cachedCounts[key] !== 'number') cachedCounts[key] = 0;
                      });
                      cachedTimestamp = localStorage.getItem("questionCountsTimestamp");
                  } catch (e) {
                      console.error("Error reading question counts from localStorage", e);
                      cachedCounts = { ...defaultCounts }; // Use default on error
                      localStorage.removeItem("questionCounts");
                      localStorage.removeItem("questionCountsTimestamp");
                  }

                  const currentTime = Date.now();
                  const oneDay = 24 * 60 * 60 * 1000;
                  const isCacheStale = !cachedTimestamp || (currentTime - parseInt(cachedTimestamp)) >= oneDay;

                  populateTopicButtons(cachedCounts); // Populate with initial/cached data

                  if (isCacheStale) {
                      console.log("Cache is stale or missing. Fetching new question counts...");
                      try {
                          const snapshot = await database.ref("questions").once("value");
                          const allQsData = snapshot.val();
                          const freshCounts = { "human-body": 0, cell: 0, ecology: 0, mix: 0 };
                          let totalFetched = 0;
                          if (allQsData) {
                              Object.values(allQsData).forEach(q => {
                                  if (q && q.topic && freshCounts.hasOwnProperty(q.topic)) {
                                      freshCounts[q.topic]++;
                                      freshCounts["mix"]++; // Count for mix as well
                                      totalFetched++;
                                  }
                              });
                          }
                          if (totalFetched > 0) {
                              localStorage.setItem("questionCounts", JSON.stringify(freshCounts));
                              localStorage.setItem("questionCountsTimestamp", currentTime.toString());
                              console.log("Repopulating buttons with fresh counts:", freshCounts);
                              populateTopicButtons(freshCounts); // Update UI with fresh data
                          } else {
                               console.warn("No valid questions found during Firebase fetch.");
                          }
                      } catch (error) {
                          console.error("Error fetching fresh question counts:", error);
                          // Keep using potentially stale counts if fetch fails
                      }
                  } else {
                      console.log("Using fresh cached question counts.");
                  }
              })();

              // --- START AUTHENTICATION (MOVED/CHANGED) ---
              setupAuthentication(); // Call the new auth handler

              // Theme Toggle Listener
              if (themeToggle) {
                  themeToggle.addEventListener("change", () => {
                      vibrate(50);
                      const isDarkMode = themeToggle.checked;
                      setTheme(isDarkMode);
                      saveThemePreference(isDarkMode);
                  });
              } else {
                  console.error("Theme toggle element not found! Cannot add listener.");
              }

              // Lifeline Button Listeners
              if (fiftyFiftyButton) {
                  fiftyFiftyButton.addEventListener("click", fiftyFiftyButtonClickHandler);
              } else { console.error("Fifty-fifty button not found!"); }
              if (addTimeButton) {
                  addTimeButton.addEventListener("click", addTimeButtonClickHandler);
              } else { console.error("Add time button not found!"); }
              if (skipButton) {
                  skipButton.addEventListener("click", skipButtonClickHandler);
              } else { console.error("Skip button not found!"); }
          }

          // --- Player State Initialization (MODIFIED) ---
          function initializePlayerState() {
              // Ensure playerId is set before proceeding
              if (!playerId) {
                  console.error("Cannot initialize player state: playerId is null.");
                  // Potentially show an error state in the UI
                  if(cumulativeScoreDisplayElement) cumulativeScoreDisplayElement.textContent = "×˜×•×¢×Ÿ ××©×ª××©...";
                  if(nicknameDisplayElement) nicknameDisplayElement.textContent = "×˜×•×¢×Ÿ ××©×ª××©...";
                  return;
              }

              console.log(`Initializing player state for user: ${playerId} (Anonymous: ${isUserAnonymous})`);

              // Apply theme from localStorage first
              const savedDarkMode = localStorage.getItem("darkMode") === "true";
              setTheme(savedDarkMode);
              if(themeToggle) themeToggle.checked = savedDarkMode;

              // Check for last played topic
              const localLastTopic = localStorage.getItem("lastTopic");
              if (localLastTopic && topicNames[localLastTopic]) {
                  updateStartScreenHint(localLastTopic);
              }

              console.log("Fetching player data for playerId:", playerId);
              database.ref(`players/${playerId}`).once("value")
                  .then((snapshot) => {
                      const playerData = snapshot.val() || {};
                      console.log("Player data fetched:", playerData);

                      // Initialize score and nickname
                      cumulativePlayerScore = playerData.cumulativeScore || 0;
                      playerNickname = playerData.nickname || generateRandomUsername(); // Generate if missing

                      // --- Load persistent lifeline counts ---
                      availableSkips = (typeof playerData.availableSkips === 'number') ? playerData.availableSkips : INITIAL_SKIP_COUNT;
                      availableFiftyFifty = (typeof playerData.availableFiftyFifty === 'number') ? playerData.availableFiftyFifty : INITIAL_FIFTY_FIFTY_COUNT;
                      // addTimeUsed is not persistent, it resets based on game usage
                      // --- End Load ---

                      updateCumulativeScoreDisplay();
                      updateNicknameDisplay();
                      updateLifelineCounters(); // Update counters display after loading state

                      // Update hint if Firebase has a different last topic
                      if (playerData.lastTopic && topicNames[playerData.lastTopic] && playerData.lastTopic !== localLastTopic) {
                          updateStartScreenHint(playerData.lastTopic);
                          localStorage.setItem("lastTopic", playerData.lastTopic);
                      }

                      // Sync theme preference from Firebase if different
                      if (typeof playerData.darkMode === 'boolean' && playerData.darkMode !== savedDarkMode) {
                          setTheme(playerData.darkMode);
                          if(themeToggle) themeToggle.checked = playerData.darkMode;
                          localStorage.setItem("darkMode", playerData.darkMode.toString());
                      }

                      // Save initial data (including initial lifelines) if player doesn't exist in DB
                      // Also save if user is NOT anonymous but has no player data yet (first time playing after Google login)
                      if (!snapshot.exists() || (!isUserAnonymous && !playerData.nickname)) {
                         savePlayerInitialData(savedDarkMode); // Pass current theme state
                      }
                  })
                  .catch((error) => {
                      console.error("Error fetching player data:", error);
                      showToast("×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ×©×—×§×Ÿ");
                      // Fallback to local storage or defaults
                      cumulativePlayerScore = parseInt(localStorage.getItem("cumulativeScoreBackup") || "0");
                      playerNickname = generateRandomUsername();
                      // Fallback for lifelines
                      availableSkips = INITIAL_SKIP_COUNT;
                      availableFiftyFifty = INITIAL_FIFTY_FIFTY_COUNT;
                      updateCumulativeScoreDisplay();
                      updateNicknameDisplay();
                      updateLifelineCounters();
                  });
          }

          function savePlayerInitialData(isDarkMode) {
              if (!playerId) return;
              const initialData = {
                  cumulativeScore: 0,
                  nickname: playerNickname, // Use the already generated/fetched nickname
                  darkMode: isDarkMode,
                  createdAt: firebase.database.ServerValue.TIMESTAMP,
                  // Initialize other stats needed by rules/logic
                  correctCount: 0,
                  wrongCount: 0,
                  topicStats: {},
                  tagStats: {},
                  // --- Save initial lifeline counts ---
                  availableSkips: INITIAL_SKIP_COUNT,
                  availableFiftyFifty: INITIAL_FIFTY_FIFTY_COUNT
              };
              console.log("Saving initial player data:", initialData);
              database.ref(`players/${playerId}`).set(initialData)
                  .then(() => { console.log("Initial player data saved for new/updated player."); })
                  .catch((error) => {
                      console.error("Failed to save initial player data:", error);
                      showToast("×©×’×™××” ×‘×©××™×¨×ª × ×ª×•× ×™× ×¨××©×•× ×™×™×");
                  });
          }

          // --- Function to save persistent player state (including lifelines) ---
          async function savePlayerStateToFirebase() {
              if (!playerId) return;
              const updates = {
                  availableSkips: availableSkips,
                  availableFiftyFifty: availableFiftyFifty,
                  // Include other persistent fields if needed, e.g., nickname, theme
                  // nickname: playerNickname,
                  // darkMode: localStorage.getItem("darkMode") === "true"
              };
              console.log("Saving player state to Firebase:", updates);
              try {
                  await database.ref(`players/${playerId}`).update(updates);
                  console.log("Player lifeline state saved successfully.");
              } catch (error) {
                  console.error("Failed to save player lifeline state:", error);
                  showToast("×©×’×™××” ×‘×©××™×¨×ª ××¦×‘ ×’×œ×’×œ×™ ×”×¦×œ×”!");
              }
          }


          function updateStartScreenHint(topicId) {
              const hintElement = document.querySelector("#start-screen h2");
              if (hintElement && topicNames[topicId]) {
                  hintElement.textContent = `×‘×¤×¢× ×©×¢×‘×¨×” ×‘×—×¨×ª ${topicNames[topicId]}, ××” ×”×¤×¢×?`;
              } else if (hintElement) {
                  // Default text if no topic or invalid topic ID
                  hintElement.textContent = `××•×›×Ÿ ×œ×‘×—×•×¨ × ×•×©×?`;
              }
          }

          function editNickname() {
              if (!gameActive) { // Allow editing freely when game is not active
                  const newName = prompt("×”×›× ×¡ ×©× ××©×ª××© ×—×“×© (×¢×“ 25 ×ª×•×•×™×):", playerNickname);
                  if (newName && newName.trim() && newName.length <= 25) {
                      playerNickname = newName.trim();
                      updateNicknameDisplay();
                      saveNicknameToFirebase();
                  } else if (newName !== null && newName.length > 25) { // Check if prompt wasn't cancelled
                      showToast("×©× ×”××©×ª××© ××¨×•×š ××“×™!");
                  }
                  return;
              }

              // Pause timer if game is active
              clearInterval(timerInterval);
              const newName = prompt("×”×›× ×¡ ×©× ××©×ª××© ×—×“×© (×¢×“ 25 ×ª×•×•×™×):", playerNickname);
              if (newName && newName.trim() && newName.length <= 25) {
                  playerNickname = newName.trim();
                  updateNicknameDisplay();
                  saveNicknameToFirebase();
              } else if (newName !== null && newName.length > 25) {
                  showToast("×©× ×”××©×ª××© ××¨×•×š ××“×™!");
              }
              // Resume timer only if game was active and timer hasn't expired
              if (gameActive && !timerExpired) {
                  startTimer(false); // Pass false to not reset timer value
              }
          }

          function saveNicknameToFirebase() {
              if (!playerId) return;
              database.ref(`players/${playerId}`).update({ nickname: playerNickname })
                  .then(() => { console.log("Nickname updated in Firebase:", playerNickname); })
                  .catch((error) => {
                      console.error("Failed to update nickname:", error);
                      showToast("×©×’×™××” ×‘×¢×“×›×•×Ÿ ×©× ×”××©×ª××©");
                  });
          }

          function saveThemePreference(isDarkMode) {
              localStorage.setItem("darkMode", isDarkMode.toString());
              if (playerId) {
                  database.ref(`players/${playerId}`).update({ darkMode: isDarkMode })
                      .catch((error) => console.error("Failed to save theme preference:", error));
              }
          }

          // --- Question Loading ---
          async function loadQuestions() {
              const cachedQuestions = localStorage.getItem("questions");
              const cachedTimestamp = localStorage.getItem("questionsTimestamp");
              const currentTime = Date.now();
              const oneDay = 24 * 60 * 60 * 1000; // Cache duration

              // Check if cache is valid
              if (cachedQuestions && cachedTimestamp && (currentTime - parseInt(cachedTimestamp)) < oneDay) {
                  console.log("Using cached questions.");
                  try {
                      const parsed = JSON.parse(cachedQuestions);
                      // Basic validation of cached data
                      if (Array.isArray(parsed) && parsed.every(q => q && typeof q.id !== 'undefined')) {
                          return parsed;
                      } else {
                          console.warn("Cached questions format invalid or missing IDs, refetching.");
                          localStorage.removeItem("questions");
                          localStorage.removeItem("questionsTimestamp");
                      }
                  } catch (e) {
                      console.error("Error parsing cached questions, fetching fresh.", e);
                      localStorage.removeItem("questions");
                      localStorage.removeItem("questionsTimestamp");
                  }
              }

              // Fetch fresh questions if cache is invalid or missing
              console.log("Fetching fresh questions from Firebase...");
              try {
                  const snapshot = await database.ref("questions").once("value");
                  const questionsData = snapshot.val();
                  const fetchedQuestions = [];
                  if (questionsData) {
                      // Convert object to array and add ID
                      for (const key in questionsData) {
                          const q = questionsData[key];
                          // Validate question structure before adding
                          if (q && q.question && Array.isArray(q.answers) && typeof q.correct !== 'undefined' && q.answers.length >= 2) {
                              q.id = key; // Add the Firebase key as 'id'
                              fetchedQuestions.push(q);
                          } else {
                              console.warn(`Skipping invalid question data with key ${key}:`, q);
                          }
                      }
                  }

                  if (fetchedQuestions.length > 0) {
                      localStorage.setItem("questions", JSON.stringify(fetchedQuestions));
                      localStorage.setItem("questionsTimestamp", currentTime.toString());
                      console.log(`Fetched and cached ${fetchedQuestions.length} valid questions.`);
                      return fetchedQuestions;
                  } else {
                      console.warn("No valid questions found in Firebase!");
                      return []; // Return empty array if no valid questions found
                  }
              } catch (error) {
                  console.error("Error fetching questions from Firebase:", error);
                  showToast("×©×’×™××” ×—××•×¨×” ×‘×˜×¢×™× ×ª ×©××œ×•×ª!");
                  return []; // Return empty array on error
              }
          }

          async function loadQuestionsForTopic(topic) {
              try {
                  showToast("×˜×•×¢×Ÿ ×©××œ×•×ª...", 0); // Show loading indicator
                  saveLastTopic(topic); // Save preference
                  allQuestions = await loadQuestions(); // Get all questions (cached or fresh)
                  document.querySelectorAll(".toast").forEach(t => t.remove()); // Hide loading indicator

                  if (allQuestions.length === 0) {
                      showToast("×œ× × ×˜×¢× ×• ×©××œ×•×ª. × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£.");
                      return;
                  }

                  // Filter questions by topic
                  if (topic === "mix") {
                      questions = [...allQuestions]; // Use all questions for 'mix'
                  } else {
                      questions = allQuestions.filter(q => q && q.topic === topic);
                  }

                  // Further filter for valid structure (redundant if loadQuestions validates, but safe)
                  questions = questions.filter(q => q && q.id && q.question && Array.isArray(q.answers) && typeof q.correct !== 'undefined' && q.answers.length >= 2);

                  if (questions.length === 0) {
                      showToast(`××™×Ÿ ×©××œ×•×ª ×–××™× ×•×ª ×œ× ×•×©× "${topicNames[topic] || topic}"!`);
                      return;
                  }

                  startGame(); // Start the game with the filtered questions
              } catch (error) {
                  console.error("Error loading questions for topic:", error);
                  document.querySelectorAll(".toast").forEach(t => t.remove()); // Hide loading indicator on error
                  showToast("×—×œ×” ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©××œ×•×ª!");
              }
          }

          function saveLastTopic(topic) {
              localStorage.setItem("lastTopic", topic);
              if (playerId) {
                  database.ref(`players/${playerId}`).update({ lastTopic: topic })
                      .catch((error) => console.error("Failed to save last topic:", error));
              }
          }

          function vibrate(duration) {
              if ("vibrate" in navigator) {
                  try { navigator.vibrate(duration); } catch (e) { /* Ignore errors */ }
              }
          }

          // --- Game Logic ---
          function resetGame() {
              // Reset only game-specific counters and flags
              correctCount = 0;
              wrongCount = 0;
              currentGameScore = 0;
              currentQuestionIndex = 0;
              currentQuestion = null;
              fiftyFiftyUsedCount = 0; // Reset game usage count
              addTimeUsed = false;    // Reset game usage flag
              skipUsedCount = 0;      // Reset game usage count
              mistakeDetails = [];
              mistakenQuestions = [];
              answerSequence = [];
              answeredCorrectly = [];
              gameTagStats = {};
              currentStreak = 0;
              longestStreak = 0;
              timerValue = 120;
              totalTime = 120;
              timerExpired = false;
              gameActive = false; // Set game inactive until startGame is called

              // Reset UI elements
              if(percentageTextIngameElement) percentageTextIngameElement.textContent = "0%";
              if(percentageProgressElement) {
                  percentageProgressElement.style.strokeDashoffset = CIRCLE_CIRCUMFERENCE;
                  percentageProgressElement.className.baseVal = "status-circle-progress red"; // Reset color
              }
              if(timerTextElement) timerTextElement.textContent = timerValue;
              if(timerProgressElement) {
                  timerProgressElement.style.strokeDashoffset = 0;
                  timerProgressElement.style.stroke = "var(--accent-color)"; // Reset color
              }
              clearInterval(timerInterval); // Clear any existing timer

              // Update counters based on persistent state loaded earlier
              updateLifelineCounters();

              console.log("Game reset complete (persistent lifelines kept).");
          }


          function startGame() {
              if (!startScreen || !gameScreen || !resultScreen) {
                  console.error("Cannot start game: screen elements not found.");
                  return;
              }
              startScreen.style.display = "none";
              resultScreen.style.display = "none";
              gameScreen.style.display = "block";

              resetGame(); // Reset game-specific variables, keeps persistent lifelines
              gameActive = true; // Set game active *after* reset

              // Shuffle questions for the current game
              questions = [...questions].sort(() => Math.random() - 0.5);

              initSequence(); // Initialize the sequence display
              updatePercentage(); // Update initial percentage display (0%)
              loadQuestion(); // Load the first question
              startTimer(); // Start the game timer

              console.log(`Game started with ${questions.length} questions for topic: ${currentTopic}`);
          }

          function initSequence() {
              if (!sequenceContainer) return;
              sequenceContainer.innerHTML = "";
              const numCircles = Math.min(5, questions.length); // Show max 5 circles or total questions if fewer
              for (let i = 1; i <= numCircles; i++) {
                  const circle = document.createElement("div");
                  circle.classList.add("sequence-circle");
                  circle.textContent = i;
                  if (i === 1) circle.classList.add("current"); // Mark the first one as current
                  sequenceContainer.appendChild(circle);
              }
          }

          function shuffleAnswers(answers, correctIndex) {
              if (!Array.isArray(answers)) {
                  console.error("Invalid answers array passed to shuffleAnswers:", answers);
                  return []; // Return empty array on error
              }
              // Create a copy with correct flag
              const answersCopy = answers.map((answer, idx) => ({
                  text: answer,
                  isCorrect: idx === correctIndex,
              }));

              // Fisher-Yates shuffle
              for (let i = answersCopy.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [answersCopy[i], answersCopy[j]] = [answersCopy[j], answersCopy[i]];
              }
              return answersCopy;
          }

          function loadQuestion() {
              if (!gameActive || (timerExpired && currentQuestion)) {
                  console.log("Timer expired or game inactive, preventing next question load.");
                  if (gameActive && !currentQuestion && !timerExpired) { // End game if no question and timer hasn't run out (implies finished all questions)
                      endGame();
                  }
                  return;
              }

              // Process mistaken questions (decrement delay, find ready ones)
              const readyMistakes = [];
              mistakenQuestions = mistakenQuestions.filter(mq => {
                  if (!mq || !mq.question) return false; // Skip invalid entries
                  if (mq.delay > 0) {
                      mq.delay--;
                      return true; // Keep in pool, decrement delay
                  } else {
                      readyMistakes.push(mq.question); // Ready to be shown
                      return false; // Remove from waiting pool
                  }
              });

              // Filter available regular questions (not answered correctly, not waiting/ready mistakes)
              let availableRegularQuestions = questions.filter(q =>
                  q && q.id && q.question &&
                  !answeredCorrectly.some(aq => aq && aq.id === q.id) &&
                  !mistakenQuestions.some(mq => mq && mq.question.id === q.id) &&
                  !readyMistakes.some(rm => rm && rm.id === q.id)
              );

              console.log(`Available regular: ${availableRegularQuestions.length}, Ready mistakes: ${readyMistakes.length}, Waiting mistakes: ${mistakenQuestions.length}`);

              // Check if game should end
              if (availableRegularQuestions.length === 0 && readyMistakes.length === 0 && mistakenQuestions.length === 0) {
                  console.log("No more questions or mistakes available. Ending game.");
                  if (gameActive) endGame();
                  return;
              }

              // Select next question (prioritize mistakes with a chance)
              let nextQuestion = null;
              const showMistakeChance = 0.4; // 40% chance to show a ready mistake

              if (readyMistakes.length > 0 && (availableRegularQuestions.length === 0 || Math.random() < showMistakeChance)) {
                  // Show a ready mistake
                  const randomIndex = Math.floor(Math.random() * readyMistakes.length);
                  nextQuestion = readyMistakes.splice(randomIndex, 1)[0]; // Select and remove
                  console.log("Loading a mistake question:", nextQuestion.id);
              } else if (availableRegularQuestions.length > 0) {
                  // Show a regular question
                  // Use modulo for index to loop if needed (shouldn't be necessary with filtering)
                  currentQuestionIndex = currentQuestionIndex % availableRegularQuestions.length;
                  nextQuestion = availableRegularQuestions[currentQuestionIndex];
                  currentQuestionIndex++; // Increment for next time
                  console.log(`Loading regular question #${currentQuestionIndex}:`, nextQuestion.id);
              } else if (readyMistakes.length > 0) {
                  // Fallback: Show a mistake if no regular ones left and random chance failed
                  const randomIndex = Math.floor(Math.random() * readyMistakes.length);
                  nextQuestion = readyMistakes.splice(randomIndex, 1)[0];
                  console.log("Loading a fallback mistake question:", nextQuestion.id);
              } else {
                  // Should not happen if end game check is correct
                  console.warn("Question selection logic failed unexpectedly. Ending game.");
                  if (gameActive) endGame();
                  return;
              }

              // Put remaining ready mistakes back into the waiting pool (with delay 0)
              readyMistakes.forEach(m => {
                  if (!mistakenQuestions.some(mq => mq && mq.question.id === m.id)) {
                      mistakenQuestions.push({ question: m, delay: 0 });
                  }
              });

              // Validate the selected question
              if (!nextQuestion || !nextQuestion.id || !nextQuestion.question || !Array.isArray(nextQuestion.answers) || typeof nextQuestion.correct === 'undefined' || nextQuestion.answers.length < 2) {
                  console.error("Invalid question data selected:", nextQuestion, "Attempting to skip and load another...");
                  // Remove invalid question from all pools and try again
                  questions = questions.filter(q => q !== nextQuestion);
                  mistakenQuestions = mistakenQuestions.filter(mq => mq.question !== nextQuestion);
                  answeredCorrectly = answeredCorrectly.filter(aq => aq !== nextQuestion);
                  loadQuestion(); // Recursive call to try loading next
                  return;
              }

              // Set current question and shuffle answers
              currentQuestion = nextQuestion;
              currentQuestion.startTime = Date.now(); // Record start time for scoring
              currentQuestion.shuffledAnswers = shuffleAnswers([...currentQuestion.answers], currentQuestion.correct);

              // Validate shuffled answers
              if (!Array.isArray(currentQuestion.shuffledAnswers) || currentQuestion.shuffledAnswers.length < 2) {
                  console.error("Failed to shuffle answers or not enough answers for:", currentQuestion.id, "Skipping...");
                  questions = questions.filter(q => q !== currentQuestion);
                  mistakenQuestions = mistakenQuestions.filter(mq => mq.question !== currentQuestion);
                  loadQuestion();
                  return;
              }

              // Display question text
              if(questionElement) {
                  questionElement.innerHTML = ""; // Clear previous
                  const questionTextNode = document.createTextNode(currentQuestion.question);
                  questionElement.appendChild(questionTextNode);
                  // Optionally add question ID for debugging
                  // const idSpan = document.createElement('span');
                  // idSpan.className = 'question-id-display';
                  // idSpan.textContent = ` (ID: ${currentQuestion.id})`;
                  // questionElement.appendChild(idSpan);
              }

              // Display answer buttons
              if(answersElement) {
                  answersElement.innerHTML = ""; // Clear previous
                  currentQuestion.shuffledAnswers.forEach((answer, index) => {
                      const button = document.createElement("button");
                      button.classList.add("answer-btn");
                      button.textContent = answer.text;
                      button.style.visibility = "visible"; // Ensure visible
                      button.style.opacity = "1"; // Ensure fully opaque
                      button.disabled = false; // Ensure enabled
                      button.addEventListener("click", () => {
                          vibrate(50);
                          checkAnswer(index); // Pass the index of the clicked button
                      });
                      answersElement.appendChild(button);
                  });
              }

              // Update UI elements
              updateLifelineCounters(); // Update counters and button states
              updateSequence(); // Update the sequence display
          }

          // --- UPDATED: createScorePopup ---
          function createScorePopup(score, isStreakBonus = false, lifelineBonusText = null) {
              const popup = document.createElement("div");
              popup.classList.add("score-popup");

              let scoreText = "";
              // Add streak bonus text and emoji if applicable
              if (isStreakBonus) {
                  const randomStreakEmoji = streakEmojis[Math.floor(Math.random() * streakEmojis.length)];
                  scoreText += `${randomStreakEmoji} ×‘×•× ×•×¡ ×¨×¦×£! `;
              }
              // Add the score in "X+" format
              scoreText += `${score}+`;

              // Set the main text content
              popup.textContent = scoreText;

              // Add lifeline bonus text if applicable
              if (lifelineBonusText) {
                  const bonusSpan = document.createElement('span');
                  bonusSpan.className = 'bonus-text';
                  const randomLifelineEmoji = lifelineBonusEmojis[Math.floor(Math.random() * lifelineBonusEmojis.length)];
                  bonusSpan.textContent = `${randomLifelineEmoji} ${lifelineBonusText}`;
                  popup.appendChild(bonusSpan); // Append as a separate element for styling
              }


              document.body.appendChild(popup);

              // Animate popup
              requestAnimationFrame(() => {
                  popup.classList.add("show");
              });

              // Remove popup after animation
              setTimeout(() => {
                  popup.classList.remove("show");
                  setTimeout(() => {
                      if (popup.parentNode) {
                          popup.parentNode.removeChild(popup);
                      }
                  }, 600); // Wait for fade out transition
              }, 1500); // Increased duration slightly for multi-line text
          }


          async function updatePlayerStatsFirebase(playerId, question, isCorrect, scoreGained = 0) {
              if (!playerId || !question) return;

              const topic = question.topic || "unknown";
              const tags = Array.isArray(question.tags) ? question.tags.filter(t => t) : []; // Filter out empty tags
              const playerRef = database.ref(`players/${playerId}`);
              let updatedPlayerData; // To store the data after transaction

              try {
                  const transactionResult = await playerRef.transaction((playerData) => {
                      // Initialize player data if null (shouldn't happen often with initial save)
                      if (playerData === null) {
                          console.warn("Player data was null during transaction, re-initializing.");
                          playerData = {
                              cumulativeScore: 0, correctCount: 0, wrongCount: 0,
                              nickname: playerNickname, darkMode: localStorage.getItem("darkMode") === "true",
                              topicStats: {}, tagStats: {},
                              // Initialize lifelines if missing during transaction
                              availableSkips: INITIAL_SKIP_COUNT,
                              availableFiftyFifty: INITIAL_FIFTY_FIFTY_COUNT
                          };
                      }

                      // Ensure nested stats objects exist
                      if (!playerData.topicStats) playerData.topicStats = {};
                      if (!playerData.tagStats) playerData.tagStats = {};
                      // Ensure lifeline fields exist (might be missing if old player data)
                      if (typeof playerData.availableSkips !== 'number') playerData.availableSkips = INITIAL_SKIP_COUNT;
                      if (typeof playerData.availableFiftyFifty !== 'number') playerData.availableFiftyFifty = INITIAL_FIFTY_FIFTY_COUNT;


                      // Update general stats
                      playerData.cumulativeScore = (playerData.cumulativeScore || 0) + scoreGained;
                      playerData.correctCount = (playerData.correctCount || 0) + (isCorrect ? 1 : 0);
                      playerData.wrongCount = (playerData.wrongCount || 0) + (isCorrect ? 0 : 1);

                      // Update topic stats
                      if (!playerData.topicStats[topic]) {
                          playerData.topicStats[topic] = { correctCount: 0, wrongCount: 0 };
                      }
                      playerData.topicStats[topic].correctCount = (playerData.topicStats[topic].correctCount || 0) + (isCorrect ? 1 : 0);
                      playerData.topicStats[topic].wrongCount = (playerData.topicStats[topic].wrongCount || 0) + (isCorrect ? 0 : 1);

                      // Update tag stats
                      tags.forEach(tag => {
                          if (!playerData.tagStats[tag]) {
                              playerData.tagStats[tag] = { correctCount: 0, wrongCount: 0 };
                          }
                          playerData.tagStats[tag].correctCount = (playerData.tagStats[tag].correctCount || 0) + (isCorrect ? 1 : 0);
                          playerData.tagStats[tag].wrongCount = (playerData.tagStats[tag].wrongCount || 0) + (isCorrect ? 0 : 1);
                      });

                      // Update lifeline counts (reflecting usage *during* the game)
                      // These are the persistent counts, updated by the handlers
                      playerData.availableSkips = availableSkips;
                      playerData.availableFiftyFifty = availableFiftyFifty;


                      return playerData; // Return the modified data for Firebase to save
                  });

                  // Check if the transaction was successful
                  if (transactionResult.committed && transactionResult.snapshot.exists()) {
                      console.log("Player stats transaction committed.");
                      updatedPlayerData = transactionResult.snapshot.val();

                      // Update local score state *only* after successful commit
                      cumulativePlayerScore = updatedPlayerData.cumulativeScore;
                      // Update local lifeline state based on committed data (handles potential conflicts)
                      availableSkips = updatedPlayerData.availableSkips;
                      availableFiftyFifty = updatedPlayerData.availableFiftyFifty;

                      updateCumulativeScoreDisplay(); // Update UI with committed value
                      updateLifelineCounters(); // Update lifeline UI
                      localStorage.setItem("cumulativeScoreBackup", cumulativePlayerScore.toString()); // Backup locally

                      // Update the separate leaderboard node
                      await database.ref(`leaderboard/${playerId}`).set({
                          nickname: updatedPlayerData.nickname,
                          cumulativeScore: updatedPlayerData.cumulativeScore
                          // Add other fields to leaderboard if needed (e.g., total correct)
                      });
                      console.log("Leaderboard updated.");

                  } else {
                      console.log("Player stats transaction was not committed (aborted or no changes).");
                  }
              } catch (error) {
                  console.error("Error updating player stats/leaderboard via transaction:", error);
                  showToast("×©×’×™××” ×‘×¢×“×›×•×Ÿ × ×ª×•× ×™× ×•×“×™×¨×•×’!");
                  // Avoid updating local score display if DB update failed
              }
          }

          // --- UPDATED: checkAnswer ---
          function checkAnswer(selectedIndex) {
              if (!gameActive || !currentQuestion || !currentQuestion.shuffledAnswers) return;

              const answerTime = Date.now();
              const timeTakenMs = answerTime - (currentQuestion.startTime || answerTime);
              const timeTakenSec = Math.max(0, Math.floor(timeTakenMs / 1000));

              // Disable all answer buttons immediately
              const buttons = answersElement.querySelectorAll(".answer-btn");
              buttons.forEach(btn => btn.disabled = true);

              // Find the selected and correct answer objects from the shuffled list
              const correctAnswerObject = currentQuestion.shuffledAnswers.find(a => a.isCorrect);
              const selectedAnswerObject = currentQuestion.shuffledAnswers[selectedIndex];

              // Basic validation
              if (!selectedAnswerObject || typeof selectedAnswerObject.isCorrect === 'undefined' || !correctAnswerObject) {
                  console.error("Error identifying selected or correct answer object.");
                  setTimeout(loadQuestion, 1200); // Try loading next question after delay
                  return;
              }

              const isCorrect = selectedAnswerObject.isCorrect;
              const questionNumber = correctCount + wrongCount + 1; // Question number in this game session
              let questionScore = 0;
              let isStreakScoreBonus = false; // Flag for streak score bonus text
              let lifelineBonusMessage = null; // Message for lifeline bonus

              // Apply styling to buttons based on correctness
              buttons.forEach((btn, idx) => {
                  if (currentQuestion.shuffledAnswers[idx]?.isCorrect) {
                      btn.classList.add("correct"); // Highlight correct answer
                  } else if (idx === selectedIndex) {
                      btn.classList.add("wrong"); // Highlight wrong selection
                  } else {
                      // Fade out other incorrect answers if 50:50 wasn't used or they weren't hidden
                      if (btn.style.visibility !== 'hidden') {
                          btn.style.opacity = "0.5";
                      }
                  }
              });

              // Update game state based on correctness
              if (isCorrect) {
                  correctCount++;
                  currentStreak++;
                  longestStreak = Math.max(longestStreak, currentStreak);
                  answerSequence.push({ number: questionNumber, correct: true });

                  // Calculate score
                  const timeBonus = Math.max(0, Math.floor((15 - timeTakenSec) / 2)); // Bonus for speed
                  const streakBonus = currentStreak > 1 ? (currentStreak - 1) * STREAK_BONUS_MULTIPLIER : 0;
                  questionScore = BASE_SCORE_PER_QUESTION + timeBonus + streakBonus;
                  if (streakBonus > 0) { isStreakScoreBonus = true; } // Set flag for popup text
                  currentGameScore += questionScore;

                  // --- NEW: Check for Lifeline Bonus ---
                  if (currentStreak >= STREAK_THRESHOLD && Math.random() < LIFELINE_BONUS_CHANCE) {
                      const bonusRand = Math.random();
                      if (bonusRand < SKIP_BONUS_PROBABILITY) { // ~12% overall
                          availableSkips++;
                          lifelineBonusMessage = "×“×™×œ×•×’ ×‘×•× ×•×¡!";
                          console.log("Awarded Skip Bonus!");
                      } else if (bonusRand < SKIP_BONUS_PROBABILITY + FIFTY_FIFTY_BONUS_PROBABILITY) { // ~5% overall
                          availableFiftyFifty++;
                          lifelineBonusMessage = "50:50 ×‘×•× ×•×¡!";
                          console.log("Awarded 50:50 Bonus!");
                      } else { // ~3% overall
                          if (addTimeUsed) { // Only award if it was used
                             addTimeUsed = false; // Make it available again
                             lifelineBonusMessage = "×ª×•×¡×¤×ª ×–××Ÿ ×‘×•× ×•×¡!";
                             console.log("Awarded Add Time Bonus!");
                          }
                      }
                      if (lifelineBonusMessage) {
                          updateLifelineCounters(); // Update UI immediately if bonus awarded
                      }
                  }
                  // --- END NEW ---

                  createScorePopup(questionScore, isStreakScoreBonus, lifelineBonusMessage); // Show score feedback (potentially with bonus text)

                  // Remove from mistaken pool if it was a mistake correction
                  const mistakeIndex = mistakenQuestions.findIndex(mq => mq && mq.question.id === currentQuestion.id);
                  if (mistakeIndex > -1) {
                      mistakenQuestions.splice(mistakeIndex, 1);
                      console.log("Corrected a mistake, removed from pool.");
                  }
                  // Add to correctly answered list (if not already there)
                  if (!answeredCorrectly.some(aq => aq && aq.id === currentQuestion.id)) {
                      answeredCorrectly.push(currentQuestion);
                  }

              } else { // Incorrect answer
                  wrongCount++;
                  currentStreak = 0; // Reset streak
                  questionScore = 0; // No score for wrong answer
                  answerSequence.push({ number: questionNumber, correct: false });

                  // Record mistake details for review
                  mistakeDetails.push({
                      question: currentQuestion.question,
                      selected: selectedAnswerObject.text,
                      correct: correctAnswerObject.text,
                      tags: currentQuestion.tags || [],
                  });

                  // Add/update in mistaken questions pool
                  const mistakeIndex = mistakenQuestions.findIndex(mq => mq && mq.question.id === currentQuestion.id);
                  const delay = Math.floor(Math.random() * 3) + 2; // Delay before showing again (2-4 questions)
                  if (mistakeIndex === -1) {
                      // Only add if not already answered correctly previously
                      if (!answeredCorrectly.some(aq => aq && aq.id === currentQuestion.id)) {
                          mistakenQuestions.push({ question: currentQuestion, delay: delay });
                          console.log(`Added mistake ${currentQuestion.id} to pool with delay ${delay}. Pool size: ${mistakenQuestions.length}`);
                      } else {
                          console.log(`Mistake ${currentQuestion.id} answered wrong, but already answered correctly earlier. Not adding back.`);
                      }
                  } else {
                      // If answered wrong again, reset the delay
                      mistakenQuestions[mistakeIndex].delay = delay;
                      console.log(`Mistake ${currentQuestion.id} answered wrong again, resetting delay to ${delay}.`);
                  }
              }

              // Update tag stats for this game session
              const questionTags = Array.isArray(currentQuestion.tags) ? currentQuestion.tags.filter(t => t) : [];
              questionTags.forEach(tag => {
                  if (!gameTagStats[tag]) gameTagStats[tag] = { correct: 0, wrong: 0 };
                  gameTagStats[tag][isCorrect ? 'correct' : 'wrong']++;
              });

              // Update Firebase stats (asynchronously) - This now also saves lifeline state implicitly
              if (playerId) {
                  updatePlayerStatsFirebase(playerId, currentQuestion, isCorrect, questionScore)
                      .catch(e => console.error("Background stat update failed:", e)); // Log async errors
              }

              // Update UI
              updatePercentage(); // Update accuracy display
              currentQuestion = null; // Mark question as answered

              // Load next question or end game
              if (timerExpired) {
                  console.log("Timer expired, ending game after answering last question.");
                  setTimeout(endGame, 1200); // Delay to show result styling
              } else {
                  setTimeout(loadQuestion, 1200); // Delay before loading next
              }
          }


          function updateSequence() {
              if (!sequenceContainer) return;
              sequenceContainer.innerHTML = ""; // Clear previous circles
              const totalAnswered = answerSequence.length;
              const currentQNumInGame = totalAnswered + 1;
              const displayCount = 5; // Always show 5 circles

              // Calculate the starting number for the sequence display
              let startNum = Math.max(1, currentQNumInGame - Math.floor(displayCount / 2));
              // Adjust if we are near the end and showing 5 would go past the current number unnecessarily
              // This part might be complex if total questions < 5, simplified for now
              // Let's keep it simple: center around current question number

              for (let i = 0; i < displayCount; i++) {
                  const displayNum = startNum + i;
                  const circle = document.createElement("div");
                  circle.classList.add("sequence-circle");
                  circle.textContent = displayNum;

                  // Find the result for this question number in the sequence history
                  const answer = answerSequence.find(a => a.number === displayNum);

                  if (displayNum === currentQNumInGame) {
                      circle.classList.add("current"); // Highlight the upcoming question
                  } else if (answer) {
                      // Style based on past answer
                      circle.classList.add(answer.correct ? "correct" : "wrong");
                  }
                  // Else: it's a future question beyond the current one, default style applies

                  sequenceContainer.appendChild(circle);
              }
          }

          function updatePercentage() {
              const total = correctCount + wrongCount;
              const percentage = total === 0 ? 0 : Math.round((correctCount / total) * 100);

              if(percentageTextIngameElement) percentageTextIngameElement.textContent = `${percentage}%`;

              if(percentageProgressElement) {
                  const offset = CIRCLE_CIRCUMFERENCE * (1 - percentage / 100);
                  percentageProgressElement.style.strokeDashoffset = Math.max(0, Math.min(CIRCLE_CIRCUMFERENCE, offset));

                  // Update color based on percentage
                  let colorClass = "red";
                  if (percentage >= 75) colorClass = "green";
                  else if (percentage >= 55) colorClass = "yellow";
                  percentageProgressElement.className.baseVal = `status-circle-progress ${colorClass}`;
              }
          }

          function startTimer(reset = true) {
              if (reset) {
                  timerValue = 120; // Reset timer value only if requested
                  totalTime = 120; // Reset total time as well
              }
              timerExpired = false;
              if(timerTextElement) timerTextElement.textContent = timerValue;
              updateTimerCircle(); // Update visual display
              clearInterval(timerInterval); // Clear any previous interval

              timerInterval = setInterval(() => {
                  if (!gameActive) { // Stop if game becomes inactive
                      clearInterval(timerInterval);
                      return;
                  }

                  if (timerValue > 0) {
                      timerValue--;
                      if(timerTextElement) timerTextElement.textContent = timerValue;
                      updateTimerCircle(); // Update visual progress

                      // Update color and vibrate on thresholds
                      if (timerValue <= 30 && timerValue > 0) {
                           if(timerProgressElement) timerProgressElement.style.stroke = "var(--danger-color)"; // Red
                           if (timerValue === 30 || timerValue === 20 || timerValue === 10) vibrate(300);
                           else if (timerValue < 10 && timerValue % 2 === 0) vibrate(150);
                      } else if (timerValue > 30) {
                           if(timerProgressElement) timerProgressElement.style.stroke = "var(--accent-color)"; // Default accent color
                      }
                  }

                  // Handle timer expiration
                  if (timerValue <= 0 && !timerExpired) {
                      timerExpired = true;
                      if(timerTextElement) timerTextElement.textContent = "0";
                      console.log("Timer reached 0. Flag set. Game will end after current/next action.");
                      vibrate([200, 100, 200]); // Vibrate pattern for expiration

                      // Disable lifelines immediately
                      updateLifelineCounters();

                      // End game immediately if no question is currently displayed
                      if (!currentQuestion) {
                          console.log("Timer expired between questions. Ending game now.");
                          endGame();
                      } else {
                          console.log("Timer expired while question is shown. Waiting for answer/skip.");
                          // Game will end after the current question is handled in checkAnswer/skipButtonClickHandler
                      }
                  }
              }, 1000); // Run every second
          }


          function updateTimerCircle() {
              if (!timerProgressElement) return;
              const clampedTime = Math.max(0, timerValue);
              const timeRatio = totalTime > 0 ? clampedTime / totalTime : 0;
              const offset = CIRCLE_CIRCUMFERENCE * (1 - timeRatio);
              timerProgressElement.style.strokeDashoffset = Math.max(0, Math.min(CIRCLE_CIRCUMFERENCE, offset));
          }

          // --- Lifeline Handlers ---
          function fiftyFiftyButtonClickHandler() {
              // Check if lifeline is available and game conditions are met
              if (availableFiftyFifty > 0 && currentQuestion && currentQuestion.shuffledAnswers && !timerExpired && gameActive) {
                  vibrate(50);
                  availableFiftyFifty--; // Decrement count
                  fiftyFiftyUsedCount++; // Increment used count for this game
                  updateLifelineCounters(); // Update display and button state

                  const buttons = answersElement.querySelectorAll(".answer-btn");
                  const incorrectButtonsIndices = [];

                  // Find indices of incorrect, visible buttons
                  currentQuestion.shuffledAnswers.forEach((answer, index) => {
                      if (!answer.isCorrect && buttons[index] && buttons[index].style.visibility !== 'hidden') {
                          incorrectButtonsIndices.push(index);
                      }
                  });

                  // Shuffle the incorrect indices
                  incorrectButtonsIndices.sort(() => Math.random() - 0.5);

                  // Hide two incorrect answers
                  let hiddenCount = 0;
                  for (let i = 0; i < incorrectButtonsIndices.length && hiddenCount < 2; i++) {
                      const btnIndex = incorrectButtonsIndices[i];
                      if (buttons[btnIndex]) {
                          buttons[btnIndex].style.visibility = 'hidden'; // Hide the button
                          buttons[btnIndex].disabled = true; // Also disable it
                          hiddenCount++;
                      }
                  }
                  console.log(`50:50 used (${availableFiftyFifty} remaining), hid ${hiddenCount} incorrect answers.`);
                  // No need to explicitly save here, will be saved in endGame or stats update
              } else {
                   console.log("50:50 not available or conditions not met.");
              }
          }

          function addTimeButtonClickHandler() {
              // Check if lifeline is available and game conditions are met
              if (!addTimeUsed && !timerExpired && gameActive) {
                  vibrate(50);
                  addTimeUsed = true; // Mark as used (only one use)
                  updateLifelineCounters(); // Update button state (will disable it)

                  timerValue += 30; // Add 30 seconds
                  totalTime += 30; // Adjust total time for percentage calculation if needed
                  if(timerTextElement) timerTextElement.textContent = timerValue; // Update display
                  updateTimerCircle(); // Update visual progress

                  // Reset timer color if it went above 30 seconds
                  if (timerValue > 30 && timerProgressElement) {
                      timerProgressElement.style.stroke = "var(--accent-color)";
                  }
                  console.log("+30 seconds used. New time:", timerValue, "New total:", totalTime);
                  // No need to explicitly save here
              } else {
                   console.log("Add time not available or conditions not met.");
              }
          }

          function skipButtonClickHandler() {
              // Check if lifeline is available and game conditions are met
              if (availableSkips > 0 && currentQuestion && currentQuestion.shuffledAnswers && !timerExpired && gameActive) {
                  vibrate(50);
                  availableSkips--; // Decrement count
                  skipUsedCount++; // Increment used count for this game
                  updateLifelineCounters(); // Update display and button state

                  console.log(`Skip used (${availableSkips} remaining).`);

                  // Briefly show the correct answer before skipping
                  const answerBtns = answersElement.querySelectorAll(".answer-btn");
                  answerBtns.forEach(btn => {
                      btn.disabled = true; // Disable all buttons
                      // Find corresponding answer object
                      const answerObj = currentQuestion.shuffledAnswers.find(a => a.text === btn.textContent);
                      if (answerObj?.isCorrect) {
                          btn.classList.add("correct"); // Highlight correct
                      } else {
                          // Fade out incorrect ones that weren't hidden
                          if (btn.style.visibility !== 'hidden') {
                              btn.style.opacity = "0.5";
                          }
                      }
                  });

                  const skippedQuestion = currentQuestion;
                  currentQuestion = null; // Mark as skipped/answered

                  // Add to mistake pool if not already answered correctly
                  const mistakeIndex = mistakenQuestions.findIndex(mq => mq && mq.question.id === skippedQuestion.id);
                  if (mistakeIndex === -1 && !answeredCorrectly.some(aq => aq && aq.id === skippedQuestion.id)) {
                      mistakenQuestions.push({ question: skippedQuestion, delay: 1 }); // Add with short delay
                      console.log(`Added skipped question ${skippedQuestion.id} to mistake pool.`);
                  }

                  // Load next question after a short delay
                  setTimeout(() => {
                      if (!timerExpired) { // Re-enable skip button only if timer hasn't run out
                          updateLifelineCounters();
                      }
                      loadQuestion();
                  }, 1000); // Delay to show correct answer briefly
                  // No need to explicitly save here
              } else {
                   console.log("Skip not available or conditions not met.");
              }
          }

          // --- End Game and Results ---
          function launchConfetti() {
              if (typeof confetti !== 'function') return; // Check if confetti library loaded

              const totalQuestions = correctCount + wrongCount;
              const percentage = totalQuestions === 0 ? 0 : Math.round((correctCount / totalQuestions) * 100);
              let particleCount = 100;
              if (percentage >= 90) particleCount = 150;
              if (percentage < 50) particleCount = 50;

              // Basic confetti burst
              confetti({
                  particleCount: particleCount,
                  spread: 70,
                  origin: { y: 0.6 },
              });

              // Extra confetti from sides for high scores
              if (percentage >= 80) {
                  const end = Date.now() + 1.5 * 1000; // Duration of side bursts
                  const colors = ['#a3bffa', '#7f9cf5', '#ffffff', '#48bb78']; // Theme colors
                  (function frame() {
                      confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0, y: 0.7 }, colors: colors });
                      confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1, y: 0.7 }, colors: colors });
                      if (Date.now() < end) {
                          requestAnimationFrame(frame);
                      }
                  })();
              }
          }

          function saveGameResult() {
              if (!playerId) return;
              const now = new Date();
              const dateStr = now.toISOString().split('T')[0]; //<x_bin_992>-MM-DD format
              const timestamp = now.toISOString();
              const totalQuestions = correctCount + wrongCount;

              // Avoid saving empty games
              if (totalQuestions === 0 && currentGameScore === 0) {
                  console.log("Skipping save for empty game.");
                  return;
              }

              const result = {
                  correctCount: correctCount,
                  totalQuestions: totalQuestions,
                  longestStreak: longestStreak,
                  score: currentGameScore,
                  timestamp: timestamp,
                  topic: currentTopic || "unknown",
                  tools: {
                      // Store counts of times used
                      fiftyFifty: fiftyFiftyUsedCount,
                      addTime: addTimeUsed, // Still boolean for single use
                      skips: skipUsedCount,
                  },
                  nickname: playerNickname, // Save nickname with result
              };

              const resultRef = database.ref(`gameResults/${dateStr}/${playerId}`);

              // Check existing result to save only the best for the day
              resultRef.once("value")
                  .then(snapshot => {
                      const existingResult = snapshot.val();
                      let shouldUpdate = true;

                      if (existingResult) {
                          // Prioritize correctCount, then score, then streak
                          if (result.correctCount < existingResult.correctCount) { shouldUpdate = false; }
                          else if (result.correctCount === existingResult.correctCount) {
                              if ((result.score || 0) < (existingResult.score || 0)) { shouldUpdate = false; }
                              else if ((result.score || 0) === (existingResult.score || 0)) {
                                  if ((result.longestStreak || 0) <= (existingResult.longestStreak || 0)) { shouldUpdate = false; }
                              }
                          }
                      }

                      if (shouldUpdate) {
                          resultRef.set(result)
                              .then(() => console.log("Daily best game result saved/updated."))
                              .catch(err => console.error("Error saving game result:", err));
                      } else {
                          console.log("Existing daily result is better or equal, not updating.");
                      }
                  })
                  .catch(err => console.error("Error fetching existing game result:", err));

              // Backup cumulative score locally (updated via transaction)
              localStorage.setItem("cumulativeScoreBackup", cumulativePlayerScore.toString());
          }


          async function getDailyRankings() {
              if (!playerId) return { rankings: [], currentPlayerRank: -1 };
              const dateStr = new Date().toISOString().split('T')[0];
              try {
                  const snapshot = await database.ref(`gameResults/${dateStr}`)
                      .orderByChild("correctCount") // Primary sort
                      .limitToLast(100) // Fetch top 100 candidates
                      .once("value");
                  const results = snapshot.val() || {};

                  const resultArray = Object.entries(results).map(([pid, data]) => ({
                      playerId: pid,
                      correctCount: data.correctCount || 0,
                      score: data.score || 0, // For tie-breaking
                      longestStreak: data.longestStreak || 0, // For tie-breaking
                      nickname: data.nickname || `×©×—×§×Ÿ...${pid.substring(pid.length - 4)}`,
                  }));

                  // Secondary sort in code: correct (desc), score (desc), streak (desc)
                  resultArray.sort((a, b) =>
                      b.correctCount - a.correctCount ||
                      b.score - a.score ||
                      b.longestStreak - a.longestStreak
                  );

                  const currentPlayerRank = resultArray.findIndex(r => r.playerId === playerId) + 1; // 1-based rank

                  return {
                      rankings: resultArray,
                      currentPlayerRank: currentPlayerRank > 0 ? currentPlayerRank : -1, // -1 if not found
                  };
              } catch (error) {
                  console.error("Error fetching daily rankings:", error);
                  return { rankings: [], currentPlayerRank: -1 }; // Return empty on error
              }
          }


          async function getOverallRankings(limit = 10) {
              if (!playerId) return { rankings: [], currentPlayerRank: -1 };
              try {
                  // Fetch directly from the pre-calculated /leaderboard node
                  const snapshot = await database.ref('leaderboard')
                      .orderByChild('cumulativeScore') // Order by score
                      .limitToLast(limit) // Get top 'limit' players
                      .once('value');
                  const results = snapshot.val() || {};

                  const resultArray = Object.entries(results).map(([pid, data]) => ({
                      playerId: pid,
                      cumulativeScore: data.cumulativeScore || 0,
                      nickname: data.nickname || `×©×—×§×Ÿ...${pid.substring(pid.length - 4)}`
                  }));

                  // Sort descending (Firebase returns ascending with limitToLast)
                  resultArray.sort((a, b) => b.cumulativeScore - a.cumulativeScore);

                  const currentPlayerRank = resultArray.findIndex(r => r.playerId === playerId) + 1;

                  return {
                      rankings: resultArray,
                      currentPlayerRank: currentPlayerRank > 0 ? currentPlayerRank : -1
                  };
              } catch (error) {
                  console.error("Error fetching overall rankings from /leaderboard:", error);
                  return { rankings: [], currentPlayerRank: -1 }; // Return empty on error
              }
          }


          function displayRankings(element, rankings, currentPlayerRank, scoreField, rankLabelPrefix = "") {
              if (!element) return;
              element.innerHTML = ""; // Clear previous content

              if (!rankings || rankings.length === 0) {
                  element.innerHTML = "<p>××™×Ÿ × ×ª×•× ×™ ×“×™×¨×•×’ ×–××™× ×™× ×›×¨×’×¢.</p>";
                  return;
              }

              const list = document.createElement("ul");
              rankings.forEach((player, index) => {
                  const rank = index + 1;
                  const li = document.createElement("li");
                  if (player.playerId === playerId) {
                      li.classList.add("current-player"); // Highlight current player
                  }

                  // Rank Number
                  const rankSpan = document.createElement("span");
                  rankSpan.className = "rank-number";
                  rankSpan.textContent = `#${rank}`;

                  // Player Nickname
                  const nameSpan = document.createElement("span");
                  nameSpan.className = "rank-name";
                  nameSpan.textContent = player.nickname;

                  // Player Score/Value
                  const scoreSpan = document.createElement("span");
                  scoreSpan.className = "rank-score";
                  scoreSpan.textContent = (player[scoreField] || 0).toLocaleString(); // Display the relevant score

                  li.appendChild(rankSpan);
                  li.appendChild(nameSpan);
                  li.appendChild(scoreSpan);
                  list.appendChild(li);
              });

              element.appendChild(list);

              // Add message if player is not in the displayed top list
              const totalQuestionsAnswered = correctCount + wrongCount;
              if (currentPlayerRank === -1 && (scoreField !== 'cumulativeScore' || totalQuestionsAnswered > 0)) {
                   let playerScoreText = '';
                   if (scoreField === 'cumulativeScore') {
                       playerScoreText = cumulativePlayerScore.toLocaleString();
                   } else if (scoreField === 'correctCount') {
                       playerScoreText = `${correctCount}/${totalQuestionsAnswered}`;
                   } else { // Assume game score
                       playerScoreText = currentGameScore.toLocaleString();
                   }
                   element.innerHTML += `<p style="font-size: 0.8rem; margin-top: 5px;">×”×“×™×¨×•×’ ×©×œ×š ××—×•×¥ ×œ-${rankings.length} ×”×¨××©×•× ×™× (${rankLabelPrefix}${playerScoreText}).</p>`;
              }
          }


          async function endGame() {
              if (!gameActive) return; // Prevent multiple calls
              gameActive = false; // Mark game as inactive
              console.log("Game ended. Displaying results.");

              clearInterval(timerInterval); // Stop the timer

              // Hide game screen, show results screen
              if(gameScreen) gameScreen.style.display = "none";
              if(resultScreen) resultScreen.style.display = "block";

              // Save game result (updates local score backup)
              saveGameResult();

              // --- Reset lifelines IF they were used ---
              let lifelinesReset = false;
              if (skipUsedCount > 0) {
                  console.log(`Resetting available skips from ${availableSkips} to ${INITIAL_SKIP_COUNT} because skips were used.`);
                  availableSkips = INITIAL_SKIP_COUNT;
                  lifelinesReset = true;
              }
              if (fiftyFiftyUsedCount > 0) {
                  console.log(`Resetting available 50:50 from ${availableFiftyFifty} to ${INITIAL_FIFTY_FIFTY_COUNT} because 50:50 was used.`);
                  availableFiftyFifty = INITIAL_FIFTY_FIFTY_COUNT;
                  lifelinesReset = true;
              }
              if (addTimeUsed) {
                  console.log("Resetting addTimeUsed flag because it was used.");
                  addTimeUsed = false; // Reset the flag so it's available next game
                  lifelinesReset = true; // Consider this a reset for saving purposes
              }

              // --- Save updated lifeline state to Firebase ---
              // Save state regardless of reset, to persist unused counts too
              await savePlayerStateToFirebase();

              // Calculate final stats
              const totalQuestions = correctCount + wrongCount;
              const percentage = totalQuestions === 0 ? 0 : Math.round((correctCount / totalQuestions) * 100);
              const endTimeValue = timerExpired ? 0 : timerValue; // Use remaining time or 0 if expired
              const timeSpent = totalTime - endTimeValue;
              const avgTimePerQuestion = totalQuestions === 0 ? 0 : Math.round(timeSpent / totalQuestions);

              // Display Scores and Stats
              if (scoreElement) scoreElement.innerHTML = `× ×™×§×•×“ ×‘××©×—×§: <span class="highlight">${currentGameScore.toLocaleString()}</span><br>× ×™×§×•×“ ××¦×˜×‘×¨: ${cumulativePlayerScore.toLocaleString()}`;
              if (accuracyStatsElement) accuracyStatsElement.innerHTML = `× ×›×•× ×•×ª: ${correctCount}/${totalQuestions} | ×¨×¦×£ ×©×™×: ${longestStreak} | ×–××Ÿ ×××•×¦×¢: ${avgTimePerQuestion} ×©× '`;

              // Result Circle Animation
              if (resultProgressCircleElement && percentageTextResultElement) {
                  const resultOffset = RESULT_CIRCLE_CIRCUMFERENCE * (1 - percentage / 100);
                  resultProgressCircleElement.style.strokeDashoffset = Math.max(0, Math.min(RESULT_CIRCLE_CIRCUMFERENCE, resultOffset));
                  let resultColorClass = "red";
                  if (percentage >= 75) resultColorClass = "green";
                  else if (percentage >= 55) resultColorClass = "yellow";
                  resultProgressCircleElement.setAttribute("class", `status-circle-progress ${resultColorClass}`);
                  // Animate percentage text
                  percentageTextResultElement.textContent = "0%";
                  let count = 0;
                  const percentageAnim = setInterval(() => {
                      count++;
                      if (count <= percentage) {
                          percentageTextResultElement.textContent = `${count}%`;
                      } else {
                          clearInterval(percentageAnim);
                      }
                  }, 20); // Animation speed
              }

              // Tools Used Display - UPDATED Text
              if (toolsUsedElement) {
                  let toolsTextParts = [];
                  if (fiftyFiftyUsedCount > 0) toolsTextParts.push(`50:50 (${fiftyFiftyUsedCount})`);
                  if (addTimeUsed) toolsTextParts.push("30+"); // Keep as is, since it's single use per game
                  if (skipUsedCount > 0) toolsTextParts.push(`×“×™×œ×•×’ (${skipUsedCount})`);
                  toolsUsedElement.textContent = toolsTextParts.length > 0 ? toolsTextParts.join(', ') : "×œ× × ×¢×©×” ×©×™××•×© ×‘×’×œ×’×œ×™ ×”×¦×œ×”"; // Changed text
              }

              // Fetch and Display Rankings
              if (rankingElement) rankingElement.innerHTML = "×˜×•×¢×Ÿ ×“×™×¨×•×’ ×™×•××™...";
              if (overallRankingElement) overallRankingElement.innerHTML = "×˜×•×¢×Ÿ ×“×™×¨×•×’ ×›×œ×œ×™...";
              try {
                  const [dailyData, overallData] = await Promise.all([
                      getDailyRankings(),
                      getOverallRankings(10), // Fetch top 10 overall
                  ]);
                  // Display Top 10 daily
                  displayRankings(rankingElement, dailyData.rankings.slice(0, 10), dailyData.currentPlayerRank, 'correctCount', "×ª×©×•×‘×•×ª: ");
                  // Display Top 10 overall
                  displayRankings(overallRankingElement, overallData.rankings, overallData.currentPlayerRank, 'cumulativeScore', "× ×™×§×•×“: ");
              } catch (error) {
                  console.error("Error fetching or displaying rankings:", error);
                  if(rankingElement) rankingElement.textContent = "×©×’×™××” ×‘×˜×¢×™× ×ª ×“×™×¨×•×’ ×™×•××™.";
                  if(overallRankingElement) overallRankingElement.textContent = "×©×’×™××” ×‘×˜×¢×™× ×ª ×“×™×¨×•×’ ×›×œ×œ×™.";
              }

              // Mistakes Review
              if (mistakesElement) {
                  mistakesElement.innerHTML = ""; // Clear previous
                  if (mistakeDetails.length > 0) {
                      const uniqueMistakes = new Map();
                      mistakeDetails.forEach(mistake => {
                          if (!uniqueMistakes.has(mistake.question)) {
                              uniqueMistakes.set(mistake.question, mistake);
                          }
                      });
                      uniqueMistakes.forEach(mistake => {
                          mistakesElement.innerHTML += `<div class="mistake-block"><div class="mistake-question">${mistake.question}</div><div class="wrong-answer">âŒ ×ª×©×•×‘×ª×š: ${mistake.selected}</div><div class="correct-answer">âœ… ×”×ª×©×•×‘×” ×”× ×›×•× ×”: ${mistake.correct}</div></div>`;
                      });
                  } else {
                      mistakesElement.innerHTML = totalQuestions > 0 ? '<p class="perfect">ğŸ’¯ ××•×©×œ×! ×›×œ ×”×ª×©×•×‘×•×ª × ×›×•× ×•×ª!</p>' : '<p>×œ× ×¢× ×™×ª ×¢×œ ×©××œ×•×ª ×‘××©×—×§ ×–×”.</p>';
                  }
              }

              // Tag Analysis
              if (tagAnalysisElement) {
                  tagAnalysisElement.innerHTML = ""; // Clear previous
                  const isDarkMode = document.body.classList.contains("dark-mode");
                  const colorSchemes = {
                      light: { success: { background: "#e6fffa", text: "#2c7a7b", border: "#9ae6b4" }, moderate: { background: "#fffbeb", text: "#b7791f", border: "#f6e05e" }, failure: { background: "#fff5f5", text: "#c53030", border: "#feb2b2" }, },
                      dark: { success: { background: "#2f855a", text: "#f0fff4", border: "#68d391" }, moderate: { background: "#b7791f", text: "#fffbeb", border: "#f6e05e" }, failure: { background: "#c53030", text: "#fff5f5", border: "#fc8181" }, },
                  };
                  const currentScheme = isDarkMode ? colorSchemes.dark : colorSchemes.light;
                  const successThreshold = 75, failureThreshold = 50;

                  const tagCloudData = Object.entries(gameTagStats)
                      .map(([tag, stats]) => {
                          if (!tag || typeof stats !== 'object' || stats === null) return null;
                          const total = (stats.correct || 0) + (stats.wrong || 0);
                          if (total === 0) return null;
                          const accuracy = Math.round(((stats.correct || 0) / total) * 100);
                          let colors, sortOrder;
                          if (accuracy >= successThreshold) { colors = currentScheme.success; sortOrder = 1; }
                          else if (accuracy < failureThreshold) { colors = currentScheme.failure; sortOrder = 3; }
                          else { colors = currentScheme.moderate; sortOrder = 2; }
                          let fontWeight = (stats.wrong || 0) > (stats.correct || 0) ? 'bold' : 'normal';
                          return { tag, colors, fontWeight, accuracy, correct: stats.correct || 0, total, sortOrder, };
                      })
                      .filter(item => item !== null);

                  tagCloudData.sort((a, b) => {
                      if (a.sortOrder !== b.sortOrder) return a.sortOrder - b.sortOrder;
                      return a.tag.localeCompare(b.tag, 'he'); // Sort alphabetically within groups
                  });

                  if (tagCloudData.length > 0) {
                      tagCloudData.forEach(item => {
                          const linkElement = document.createElement('a');
                          linkElement.classList.add('tag-cloud-item');
                          const searchTerm = encodeURIComponent(`${item.tag} ×‘×™×•×œ×•×’×™×”`);
                          linkElement.href = `https://www.google.com/search?q=${searchTerm}`;
                          linkElement.target = '_blank';
                          linkElement.rel = 'noopener noreferrer';
                          linkElement.style.backgroundColor = item.colors.background;
                          linkElement.style.color = item.colors.text;
                          linkElement.style.borderColor = item.colors.border;
                          linkElement.style.fontWeight = item.fontWeight;
                          linkElement.textContent = `#${item.tag}`;
                          linkElement.title = `×“×™×•×§: ${item.accuracy}% (${item.correct}/${item.total}) - ×—×¤×© '${item.tag}' ×‘×’×•×’×œ`;
                          tagAnalysisElement.appendChild(linkElement);
                      });
                  } else {
                      tagAnalysisElement.innerHTML = "<p>×œ× × ×¦×‘×¨×• × ×ª×•× ×™× ×¢×œ ×ª×’×™×•×ª ×‘××©×—×§ ×–×”.</p>";
                  }
              }

              // Share Button Logic
              if (shareButton) {
                  shareButton.onclick = () => {
                      vibrate(50);
                      const shareText = `×©×™×—×§×ª×™ ×˜×¨×™×•×•BIO ×‘× ×•×©× ${topicNames[currentTopic] || '××¢×•×¨×‘'} ×•×”×©×’×ª×™ ${currentGameScore.toLocaleString()} × ×§×•×“×•×ª (${percentage}% ×“×™×•×§) ×¢× ×¨×¦×£ ×©×™× ×©×œ ${longestStreak}! ğŸ‰ ×¡×”"×› ×¦×‘×¨×ª×™ ${cumulativePlayerScore.toLocaleString()} × ×§×•×“×•×ª. ×”×©× ×©×œ×™: ${playerNickname}. ×‘×•××• ×œ×©×—×§ ×’×!`;
                      let currentUrl = window.location.href.replace(/#.*$/, ""); // Clean URL
                      const shareData = { title: "×˜×¨×™×•×•BIO - ×ª×•×¦××ª ××©×—×§", text: shareText, url: currentUrl };

                      if (navigator.share) {
                          navigator.share(shareData)
                              .then(() => console.log("Successful share"))
                              .catch((error) => console.log("Error sharing", error));
                      } else { // Fallback to clipboard
                          navigator.clipboard.writeText(`${shareText} ${currentUrl}`)
                              .then(() => showToast("×”×ª×•×¦××” ×•×”×§×™×©×•×¨ ×”×•×¢×ª×§×•!"))
                              .catch(err => {
                                  console.error("Failed to copy text: ", err);
                                  showToast("×©×’×™××” ×‘×”×¢×ª×§×ª ×”×ª×•×¦××”.");
                              });
                      }
                  };
              }

              // Restart Button Logic
              if (restartButton) {
                  restartButton.onclick = () => {
                      vibrate(50);
                      if(resultScreen) resultScreen.style.display = "none";
                      if(startScreen) startScreen.style.display = "block";
                      // Game state reset happens when a new topic is chosen via startGame()
                      // Lifeline state is now persistent and loaded in initializePlayerState
                  };
              }

              launchConfetti(); // Fire confetti!
          }


          // --- Wait for DOMContentLoaded before running main logic ---
          document.addEventListener('DOMContentLoaded', () => {
              console.log("DOMContentLoaded event fired.");
              try {
                  if (initializeDOMElements()) { // Initialize DOM elements first
                      mainAppLogic(); // Run main logic only if DOM elements are found
                  }
              } catch (error) {
                  console.error("Error during DOMContentLoaded execution:", error);
                  // Display error to user if DOM init failed
                  document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">×©×’×™××” ×§×¨×™×˜×™×ª ×‘×˜×¢×™× ×ª ×”××©×—×§ (${error.message}). × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£.</div>`;
              }
          });

      } catch (error) {
          // Catch any synchronous error during script setup
          console.error("Critical error during script execution:", error);
          // Attempt to display a generic error message to the user
          try {
              document.body.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">××™×¨×¢×” ×©×’×™××” ×§×¨×™×˜×™×ª ×‘×˜×¢×™× ×ª ×”××©×—×§. ×× × × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£.<br><br>×¤×¨×˜×™ ×©×’×™××”: ${error.message}</div>`;
          } catch (e) {
              // Fallback if even modifying body fails
          }
      }
    </script>
  </body>
</html>