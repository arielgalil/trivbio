<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>×˜×¨×™×•×•BIO - ××©×—×§ ×˜×¨×™×•×•×™×” ×‘×‘×™×•×œ×•×’×™×”</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap" rel="stylesheet" />
    <style>
        body {
            font-family: "Rubik", sans-serif;
            background-color: #f7fafc;
            color: #2d3748;
            margin: 0;
            padding: 0;
            transition: background-color 0.3s, color 0.3s;
        }
        .dark-mode {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            text-align: center;
        }
        header {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        h1 {
            font-size: 2.5rem;
            margin: 0;
        }
        h2 {
            font-size: 1.5rem;
            margin: 10px 0;
        }
        button {
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }
        button:hover:not(:disabled) {
            background-color: #2b6cb0;
        }
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        .dark-mode button {
            background-color: #63b3ed;
        }
        .dark-mode button:hover:not(:disabled) {
            background-color: #4299e1;
        }
        .topic-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            justify-content: center;
            background-color: #6B7280; /* ×¦×‘×¢ ×‘×”×™×¨ ×œ××¦×‘ ×‘×”×™×¨ */
            color: white;
        }
        .topic-btn:hover {
            background-color: #4B5563; /* ××¤×§×˜ hover ×‘××¦×‘ ×‘×”×™×¨ */
        }
        .dark-mode .topic-btn {
            background-color: #4A5568; /* ×¦×‘×¢ ×›×”×” ×œ××¦×‘ ×›×”×” */
            color: #e2e8f0;
        }
        .dark-mode .topic-btn:hover {
            background-color: #2D3748; /* ××¤×§×˜ hover ×‘××¦×‘ ×›×”×” */
        }
        .question-count {
            font-size: 0.8rem;
            opacity: 0.8;
        }
        #start-screen {
            background: linear-gradient(135deg, #5B6ACF, #2B2D5B);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 20px 0;
        }
        .dark-mode #start-screen {
            background: linear-gradient(135deg, #2d3748, #1a202c);
        }
        #start-screen p {
            font-size: 1.1rem;
            line-height: 1.5;
            margin: 20px 0;
            color: #e2e8f0;
        }
        .dark-mode #start-screen p {
            color: #e2e8f0;
        }
        #start-screen-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        @media (max-width: 600px) {
            #start-screen-buttons {
                grid-template-columns: 1fr;
            }
        }
        #status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
        }
        #timer-container {
            position: relative;
            width: 53.6px;
            height: 53.6px;
        }
        #timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }
        #question {
            font-size: 1.25rem;
            margin: 20px 0;
        }
        #answers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .answer-btn {
            padding: 15px;
            text-align: right;
            font-size: 1rem;
        }
        .correct {
            background-color: #48bb78 !important;
        }
        .wrong {
            background-color: #f56565 !important;
        }
        #game-buttons {
            margin-top: 20px;
        }
        .disabled {
            background-color: #a0aec0 !important;
        }
        .result-card {
            background-color: #fff;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .dark-mode .result-card {
            background-color: #2d3748;
        }
        .progress-circle {
            position: relative;
            display: inline-block;
        }
        #percentage-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }
        .highlight {
            color: #4299e1;
            font-weight: bold;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2d3748;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 1000;
        }
        .toast.show {
            opacity: 1;
        }
        .dark-mode .toast {
            background-color: #e2e8f0;
            color: #2d3748;
        }
        footer {
            margin-top: 20px;
            font-size: 0.9rem;
            text-align: center;
        }
        footer a {
            color: #4299e1;
            text-decoration: none;
            margin: 0 5px;
        }
        .dark-mode footer a {
            color: #63b3ed;
        }
        .switch {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 34px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #4299e1;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        .theme-icon {
            width: 20px;
            height: 20px;
            transition: opacity 0.4s;
        }
        .sun {
            opacity: 1;
        }
        .moon {
            opacity: 0;
        }
        input:checked + .slider .sun {
            opacity: 0;
        }
        input:checked + .slider .moon {
            opacity: 1;
        }
        #percentage-circle {
            width: 50px;
            height: 50px;
            line-height: 50px;
            border-radius: 50%;
            background-color: #e2e8f0;
            color: #2d3748;
            font-weight: bold;
        }
        .dark-mode #percentage-circle {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        .sequence-circle {
            width: 30px;
            height: 30px;
            line-height: 30px;
            border-radius: 50%;
            background-color: #e2e8f0;
            margin: 0 5px;
            display: inline-block;
            font-size: 0.9rem;
        }
        .dark-mode .sequence-circle {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        .sequence-circle.correct {
            background-color: #48bb78;
            color: white;
        }
        .sequence-circle.wrong {
            background-color: #f56565;
            color: white;
        }
        .sequence-circle.current {
            border: 2px solid #4299e1;
        }
        .mistake-block {
            text-align: right;
            margin: 10px 0;
        }
        .mistake-question {
            font-weight: bold;
        }
        .wrong-answer {
            color: #f56565;
        }
        .correct-answer {
            color: #48bb78;
        }
        .tip {
            color: #4299e1;
            font-size: 0.9rem;
        }
        .perfect {
            color: #48bb78;
            font-weight: bold;
        }
        .tag-cloud-item {
            margin: 5px;
            display: inline-block;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .tag-cloud-item:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <script>
        if (localStorage.getItem("darkMode") === "true") {
            document.body.classList.add("dark-mode");
        }
    </script>
    <div class="container">
        <header>
            <h1>×˜×¨×™×•×•BIO</h1>
            <label class="switch">
                <input type="checkbox" id="theme-toggle" />
                <span class="slider">
                    <img src="https://img.icons8.com/ios-glyphs/30/ffffff/sun.png" alt="×©××©" class="theme-icon sun" />
                    <img src="https://img.icons8.com/ios-glyphs/30/ffffff/moon-symbol.png" alt="×™×¨×—" class="theme-icon moon" />
                </span>
            </label>
        </header>
        <main>
            <div id="start-screen">
                <h2>××•×›×Ÿ ×œ×‘×—×•×¨ × ×•×©×?</h2>
                <p>
                    ×”×“×¨×š ×”×›×™ ×˜×•×‘×” ×œ×œ××•×“ ×œ×‘×’×¨×•×ª ×‘×‘×™×•×œ×•×’×™×”? ×¤×©×•×˜ ×œ×©×—×§!
                    <br />×›×›×œ ×©×ª×¢× ×• ×¢×œ ×™×•×ª×¨ ×©××œ×•×ª â€“ ×ª×‘×™× ×•, ×ª×–×›×¨×• ×•×ª× ×¦×—×• ××ª ×”×‘×—×™× ×”.
                    <br />×˜×¨×™×•×•BIO ×”×•× ×”×“×¨×š ×”×›×™ ×›×™×¤×™×ª, ×—×›××” ×•×××•×§×“×ª ×œ×”×ª×›×•× ×Ÿ.
                </p>
                <div id="start-screen-buttons">
                    <button class="topic-btn" data-topic="human-body">×’×•×£ ×”××“× <span>ğŸ§</span></button>
                    <button class="topic-btn" data-topic="cell">×”×ª× <span>ğŸ§¬</span></button>
                    <button class="topic-btn" data-topic="ecology">××§×•×œ×•×’×™×” <span>ğŸŒ</span></button>
                    <button class="topic-btn" data-topic="mix">×¢×¨×‘×‘ ××•×ª×™ <span>ğŸ²</span></button>
                </div>
            </div>
            <div id="game-screen" style="display: none">
                <div id="status-row">
                    <div id="timer-container">
                        <svg id="timer-circle">
                            <circle cx="26.8" cy="26.8" r="25.46" stroke="#e2e8f0" stroke-width="2.68" fill="none" />
                            <circle cx="26.8" cy="26.8" r="25.46" stroke="#4299e1" stroke-width="2.68" fill="none" stroke-dasharray="159.84" stroke-dashoffset="0" id="timer-progress" />
                        </svg>
                        <div id="timer-text">120</div>
                    </div>
                    <div id="sequence-container"></div>
                    <div id="percentage-circle">0%</div>
                </div>
                <div id="question"></div>
                <div id="answers"></div>
                <div id="game-buttons">
                    <button id="fifty-fifty">50:50</button>
                    <button id="add-time">30+</button>
                    <button id="skip">×“×œ×’</button>
                </div>
            </div>
            <div id="result-screen" style="display: none">
                <div class="result-card">
                    <h3>ğŸ† ×ª×•×¦××•×ª</h3>
                    <div class="progress-circle">
                        <svg width="60" height="60">
                            <circle cx="30" cy="30" r="25" stroke="#e2e8f0" stroke-width="5" fill="none" />
                            <circle cx="30" cy="30" r="25" stroke="#4299e1" stroke-width="5" fill="none" stroke-dasharray="157" stroke-dashoffset="0" id="progress-circle" />
                        </svg>
                        <span id="percentage-text">0%</span>
                    </div>
                    <p id="score"></p>
                </div>
                <div class="result-card">
                    <h3>âš™ï¸ ×›×œ×™× ×‘×©×™××•×©</h3>
                    <p id="tools-used"></p>
                </div>
                <div class="result-card">
                    <h3>ğŸ“Š ×“×™×¨×•×’ ×™×•××™</h3>
                    <div id="ranking"></div>
                </div>
                <div class="result-card">
                    <h3>ğŸ“š ×¢× ×Ÿ ×”×ª×’×™×•×ª ×©×œ×š</h3>
                    <div id="mistakes"></div>
                    <div id="tag-analysis"></div>
                </div>
                <div class="result-buttons">
                    <button id="share-result">×©×ª×£ ×ª×•×¦××”</button>
                    <button id="restart">×©×—×§ ×©×•×‘</button>
                </div>
            </div>
        </main>
    </div>
    <footer>
        ×¤×•×ª×— ×¢×œ ×™×“×™ ××¨×™××œ ×<a href="https://galilbio.wordpress.com" target="_blank">×”Ö·×‘Ö¼Ö´×™Ö¼×•Ö¹×œ×•Ö¹×’Ö´×™× ×©×œ ×’×œ×™×œ</a> ×‘×¢×–×¨×ª <a href="https://grok.com/" target="_blank">×’×¨×•×§</a>, <a href="https://chatgpt.com/" target="_blank">Chat GPT</a> ×•-<a href="https://gemini.google.com/app" target="_blank">Gemini</a> | <a href="admin.html" target="_blank">× ×™×”×•×œ</a>
    </footer>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script>
        console.log("Script loaded and running");

        const topicNames = {
            "human-body": "×’×•×£ ×”××“×",
            "cell": "×”×ª×",
            "ecology": "××§×•×œ×•×’×™×”",
            "mix": "×¢×¨×‘×‘ ××•×ª×™",
        };

        const firebaseConfig = {
            apiKey: "AIzaSyAGFC_TB8iEMvS2PyxeASj1HH4i66AW4UA",
            authDomain: "trivbio.firebaseapp.com",
            projectId: "trivbio",
            storageBucket: "trivbio.firebasestorage.app",
            messagingSenderId: "1097087574583",
            appId: "1:1097087574583:web:b36c0441537a1f596215b2",
            measurementId: "G-ZY245YB23E",
        };

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        console.log("Firebase initialized successfully");

        (async function initializeQuestionCounts() {
            const topics = [
                { id: "human-body", name: "×’×•×£ ×”××“×", emoji: "ğŸ§" },
                { id: "cell", name: "×”×ª×", emoji: "ğŸ§¬" },
                { id: "ecology", name: "××§×•×œ×•×’×™×”", emoji: "ğŸŒ" },
                { id: "mix", name: "×¢×¨×‘×‘ ××•×ª×™", emoji: "ğŸ²" },
            ];

            let cachedCounts = JSON.parse(localStorage.getItem("questionCounts") || "{}");
            const cachedTimestamp = localStorage.getItem("questionCountsTimestamp");
            const currentTime = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;

            topics.forEach((topic) => {
                const button = document.querySelector(`.topic-btn[data-topic="${topic.id}"]`);
                if (button) {
                    const count = cachedCounts[topic.id] ?? "?";
                    button.innerHTML = `${topic.name} <span>${topic.emoji}</span> <span class="question-count">[${count} ×©××œ×•×ª]</span>`;
                }
            });

            if (!cachedTimestamp || currentTime - cachedTimestamp >= oneDay || Object.keys(cachedCounts).length === 0) {
                const questionCounts = {};
                const snapshot = await database.ref('questions').once('value');
                const allQuestions = snapshot.val() ? Object.values(snapshot.val()) : [];

                topics.forEach((topic) => {
                    if (topic.id === "mix") {
                        questionCounts["mix"] = allQuestions.length;
                    } else {
                        questionCounts[topic.id] = allQuestions.filter(q => q.topic === topic.id).length;
                    }
                });

                localStorage.setItem("questionCounts", JSON.stringify(questionCounts));
                localStorage.setItem("questionCountsTimestamp", currentTime);

                topics.forEach((topic) => {
                    const button = document.querySelector(`.topic-btn[data-topic="${topic.id}"]`);
                    if (button) {
                        const count = questionCounts[topic.id] ?? "?";
                        button.innerHTML = `${topic.name} <span>${topic.emoji}</span> <span class="question-count">[${count} ×©××œ×•×ª]</span>`;
                    }
                });
            }
        })();

        function showToast(message, duration = 3000) {
            const toast = document.createElement("div");
            toast.classList.add("toast");
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.classList.add("show"), 100);
            if (duration > 0) {
                setTimeout(() => {
                    toast.classList.remove("show");
                    setTimeout(() => toast.remove(), 500);
                }, duration);
            }
        }

        firebase.auth().signInAnonymously().then((userCredential) => {
            const playerId = userCredential.user.uid;
            startGameLogic(playerId);
        }).catch((error) => {
            console.error("Anonymous auth failed:", error);
            showToast("×—×œ×” ×©×’×™××” ×‘×”×ª×—×‘×¨×•×ª...");
        });

        async function loadQuestions() {
            const cachedQuestions = localStorage.getItem('questions');
            const cachedTimestamp = localStorage.getItem('questionsTimestamp');
            const currentTime = Date.now();
            const oneDay = 24 * 60 * 60 * 1000;

            if (cachedQuestions && cachedTimestamp && (currentTime - cachedTimestamp < oneDay)) {
                return JSON.parse(cachedQuestions);
            } else {
                const snapshot = await database.ref('questions').once('value');
                const questions = snapshot.val() ? Object.values(snapshot.val()) : [];
                localStorage.setItem('questions', JSON.stringify(questions));
                localStorage.setItem('questionsTimestamp', currentTime);
                return questions;
            }
        }

        function startGameLogic(playerId) {
            const savedDarkMode = localStorage.getItem("darkMode");
            if (savedDarkMode === "true") {
                document.body.classList.add("dark-mode");
                document.getElementById("theme-toggle").checked = true;
            } else {
                document.body.classList.remove("dark-mode");
                document.getElementById("theme-toggle").checked = false;
            }

            firebase.auth().onAuthStateChanged((user) => {
                if (user && user.uid === playerId) {
                    const isDarkMode = savedDarkMode === "true";
                    database.ref(`players/${playerId}`).update({
                        darkMode: isDarkMode,
                    });
                    database.ref(`players/${playerId}`).once("value").then((snapshot) => {
                        const playerData = snapshot.val();
                        if (playerData && playerData.lastTopic && topicNames[playerData.lastTopic]) {
                            document.querySelector("#start-screen h2").textContent = `×‘×¤×¢× ×©×¢×‘×¨×” ×‘×—×¨×ª ${topicNames[playerData.lastTopic]}, ××” ×”×¤×¢×?`;
                            localStorage.setItem("lastTopic", playerData.lastTopic);
                        }
                    });
                }
            });

            const lastTopic = localStorage.getItem("lastTopic");
            if (lastTopic && topicNames[lastTopic]) {
                document.querySelector("#start-screen h2").textContent = `×‘×¤×¢× ×©×¢×‘×¨×” ×‘×—×¨×ª ${topicNames[lastTopic]}, ××” ×”×¤×¢×?`;
            }

            const buttons = document.querySelectorAll(".topic-btn");
            buttons.forEach((button) => {
                button.addEventListener("click", async () => {
                    vibrate(50);
                    currentTopic = button.getAttribute("data-topic");
                    await loadQuestionsForTopic(currentTopic);
                });
            });

            const startScreen = document.getElementById("start-screen");
            const gameScreen = document.getElementById("game-screen");
            const resultScreen = document.getElementById("result-screen");
            const timerText = document.getElementById("timer-text");
            const timerProgress = document.getElementById("timer-progress");
            const questionElement = document.getElementById("question");
            const answersElement = document.getElementById("answers");
            const fiftyFiftyButton = document.getElementById("fifty-fifty");
            const addTimeButton = document.getElementById("add-time");
            const skipButton = document.getElementById("skip");
            const restartButton = document.getElementById("restart");
            const themeToggle = document.getElementById("theme-toggle");
            const toolsUsedElement = document.getElementById("tools-used");
            const mistakesElement = document.getElementById("mistakes");
            const sequenceContainer = document.getElementById("sequence-container");
            const percentageCircle = document.getElementById("percentage-circle");
            const tagAnalysisElement = document.getElementById("tag-analysis");

            let currentTopic = "";
            let allQuestions = [];
            let questions = [];
            let currentQuestionIndex = 0;
            let currentQuestion = null;
            let correctCount = 0;
            let wrongCount = 0;
            let timer = 120;
            let totalTime = 120;
            let timerInterval;
            let fiftyFiftyUsed = false;
            let addTimeUsed = false;
            let skipUsed = 0;
            let mistakes = [];
            let mistakenQuestions = [];
            let answerSequence = [];
            let answeredCorrectly = [];
            let lastVibrationTime = 0;
            let currentStreak = 0;
            let longestStreak = 0;

            async function loadQuestionsForTopic(topic) {
                try {
                    showToast("×˜×•×¢×Ÿ ×©××œ×•×ª...", 0);
                    saveLastTopic(topic);

                    allQuestions = await loadQuestions();

                    if (topic === "mix") {
                        questions = allQuestions;
                    } else {
                        questions = allQuestions.filter(q => q.topic === topic);
                    }

                    if (questions.length === 0) {
                        showToast("××™×Ÿ ×©××œ×•×ª ×–××™× ×•×ª ×œ× ×•×©× ×–×”!");
                        endGame();
                        return;
                    }

                    document.querySelectorAll(".toast").forEach(toast => toast.remove());
                    startGame();
                } catch (error) {
                    console.error("Error loading questions:", error);
                    showToast("×—×œ×” ×©×’×™××” ×‘×˜×¢×™× ×ª ×”×©××œ×•×ª!");
                    endGame();
                }
            }

            function saveLastTopic(topic) {
                localStorage.setItem("lastTopic", topic);
                database.ref(`players/${playerId}`).update({ lastTopic: topic });
            }

            function saveThemePreference(isDarkMode) {
                localStorage.setItem("darkMode", isDarkMode);
                database.ref(`players/${playerId}`).update({ darkMode: isDarkMode });
            }

            function saveGameResult() {
                const now = new Date();
                const dateStr = now.toISOString().split("T")[0];
                const timestamp = now.toISOString();
                const totalQuestions = correctCount + wrongCount;

                const result = {
                    correctCount,
                    totalQuestions,
                    longestStreak,
                    timestamp,
                    topic: currentTopic,
                };

                const resultRef = database.ref(`gameResults/${dateStr}/${playerId}`);
                resultRef.once("value").then((snapshot) => {
                    const existingResult = snapshot.val();
                    if (!existingResult || result.correctCount > existingResult.correctCount ||
                        (result.correctCount === existingResult.correctCount && result.totalQuestions > existingResult.totalQuestions) ||
                        (result.correctCount === existingResult.correctCount && result.totalQuestions === existingResult.totalQuestions && result.longestStreak > existingResult.longestStreak)) {
                        resultRef.set(result);
                    }
                });
            }

            async function getDailyRankings() {
                const now = new Date();
                const dateStr = now.toISOString().split("T")[0];
                const snapshot = await database.ref(`gameResults/${dateStr}`).once("value");
                const results = snapshot.val() || {};

                const resultArray = Object.entries(results).map(([pid, data]) => ({
                    playerId: pid,
                    correctCount: data.correctCount,
                    totalQuestions: data.totalQuestions,
                    longestStreak: data.longestStreak,
                }));

                const sortedByCorrect = [...resultArray].sort((a, b) => b.correctCount - a.correctCount || b.totalQuestions - a.totalQuestions || b.longestStreak - a.longestStreak);
                const rankCorrect = sortedByCorrect.findIndex((r) => r.playerId === playerId) + 1;
                const topCorrect = sortedByCorrect[0]?.correctCount || 0;
                const topStreak = sortedByCorrect[0]?.longestStreak || 0;

                return {
                    rankCorrect: rankCorrect || "×œ× ××“×•×¨×’",
                    topCorrect,
                    topStreak,
                    totalPlayers: resultArray.length,
                };
            }

            fiftyFiftyButton.addEventListener("click", () => {
                if (!fiftyFiftyUsed) {
                    vibrate(50);
                    fiftyFiftyUsed = true;
                    const correctIndex = currentQuestion.shuffledAnswers.findIndex(a => a.isCorrect);
                    let removed = 0;
                    const buttons = answersElement.querySelectorAll(".answer-btn");
                    while (removed < 2) {
                        const randomIndex = Math.floor(Math.random() * 4);
                        if (randomIndex !== correctIndex && buttons[randomIndex].style.display !== "none") {
                            buttons[randomIndex].style.display = "none";
                            removed++;
                        }
                    }
                    fiftyFiftyButton.classList.add("disabled");
                    fiftyFiftyButton.disabled = true;
                }
            });

            addTimeButton.addEventListener("click", () => {
                if (!addTimeUsed) {
                    vibrate(50);
                    addTimeUsed = true;
                    timer += 30;
                    totalTime += 30;
                    timerText.textContent = timer;
                    updateTimerCircle();
                    addTimeButton.classList.add("disabled");
                    addTimeButton.disabled = true;
                }
            });

            skipButton.addEventListener("click", () => {
                vibrate(50);
                const buttons = answersElement.querySelectorAll(".answer-btn");
                buttons.forEach((btn, idx) => {
                    btn.disabled = true;
                    if (currentQuestion.shuffledAnswers[idx].isCorrect) {
                        btn.classList.add("correct");
                    }
                });
                skipUsed++;
                setTimeout(() => {
                    currentQuestionIndex++;
                    loadQuestion();
                }, 1000);
            });

            restartButton.addEventListener("click", () => {
                vibrate(50);
                resultScreen.style.display = "none";
                startScreen.style.display = "block";
                resetGame();
            });

            themeToggle.addEventListener("change", () => {
                vibrate(50);
                document.body.classList.toggle("dark-mode");
                const isDarkMode = document.body.classList.contains("dark-mode");
                saveThemePreference(isDarkMode);
            });

            function vibrate(duration) {
                if ("vibrate" in navigator) {
                    navigator.vibrate(duration);
                }
            }

            function resetGame() {
                correctCount = 0;
                wrongCount = 0;
                currentQuestionIndex = 0;
                currentQuestion = null;
                fiftyFiftyUsed = false;
                addTimeUsed = false;
                skipUsed = 0;
                mistakes = [];
                mistakenQuestions = [];
                answerSequence = [];
                answeredCorrectly = [];
                currentStreak = 0;
                longestStreak = 0;
                fiftyFiftyButton.classList.remove("disabled");
                addTimeButton.classList.remove("disabled");
                fiftyFiftyButton.disabled = false;
                addTimeButton.disabled = false;
            }

            function startGame() {
                startScreen.style.display = "none";
                gameScreen.style.display = "block";
                resetGame();
                questions = [...questions].sort(() => Math.random() - 0.5);
                initSequence();
                updatePercentage();
                loadQuestion();
                startTimer();
            }

            function initSequence() {
                sequenceContainer.innerHTML = "";
                for (let i = 1; i <= 5; i++) {
                    const circle = document.createElement("div");
                    circle.classList.add("sequence-circle");
                    circle.textContent = i;
                    if (i === 1) circle.classList.add("current");
                    sequenceContainer.appendChild(circle);
                }
            }

            function shuffleAnswers(answers, correctIndex) {
                const shuffled = answers.map((answer, idx) => ({
                    text: answer,
                    isCorrect: idx === correctIndex,
                }));
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            function loadQuestion() {
                const readyMistakes = [];
                mistakenQuestions = mistakenQuestions.filter((mq) => {
                    if (mq.delay > 0) {
                        mq.delay--;
                        return true;
                    } else {
                        readyMistakes.push(mq.question);
                        return false;
                    }
                });

                let availableQuestions = questions.filter(q => !answeredCorrectly.some(aq => aq.question === q.question));
                if (availableQuestions.length === 0 && readyMistakes.length === 0) {
                    endGame();
                    return;
                }

                let attempts = 0;
                const maxAttempts = availableQuestions.length + readyMistakes.length;

                while (attempts < maxAttempts) {
                    if (readyMistakes.length > 0) {
                        const randomIndex = Math.floor(Math.random() * readyMistakes.length);
                        currentQuestion = readyMistakes[randomIndex];
                        readyMistakes.splice(randomIndex, 1);
                    } else {
                        if (currentQuestionIndex >= availableQuestions.length) {
                            currentQuestionIndex = 0;
                        }
                        currentQuestion = availableQuestions[currentQuestionIndex];
                        availableQuestions.splice(currentQuestionIndex, 1);
                        currentQuestionIndex++;
                    }

                    if (currentQuestion && currentQuestion.question && currentQuestion.answers && currentQuestion.correct !== undefined) {
                        break;
                    } else {
                        console.warn("Skipping invalid question:", currentQuestion);
                        attempts++;
                        currentQuestion = null;
                    }
                }

                if (!currentQuestion) {
                    endGame();
                    return;
                }

                currentQuestion.shuffledAnswers = shuffleAnswers(currentQuestion.answers, currentQuestion.correct);
                questionElement.textContent = currentQuestion.question;
                answersElement.innerHTML = "";
                currentQuestion.shuffledAnswers.forEach((answer, index) => {
                    const button = document.createElement("button");
                    button.classList.add("answer-btn");
                    button.textContent = answer.text;
                    button.addEventListener("click", () => {
                        vibrate(50);
                        checkAnswer(index);
                    });
                    answersElement.appendChild(button);
                });
                updateSequence();
            }

            async function updatePlayerStats(playerId, question, isCorrect) {
                const updates = {};
                const topic = question.topic;
                const tags = question.tags || [];

                const topicRef = database.ref(`players/${playerId}/topicStats/${topic}`);
                const topicSnapshot = await topicRef.once('value');
                const topicData = topicSnapshot.val() || { correctCount: 0, wrongCount: 0 };
                updates[`players/${playerId}/topicStats/${topic}/correctCount`] = topicData.correctCount + (isCorrect ? 1 : 0);
                updates[`players/${playerId}/topicStats/${topic}/wrongCount`] = topicData.wrongCount + (isCorrect ? 0 : 1);

                for (const tag of tags) {
                    const tagRef = database.ref(`players/${playerId}/tagStats/${tag}`);
                    const tagSnapshot = await tagRef.once('value');
                    const tagData = tagSnapshot.val() || { correctCount: 0, wrongCount: 0 };
                    updates[`players/${playerId}/tagStats/${tag}/correctCount`] = tagData.correctCount + (isCorrect ? 1 : 0);
                    updates[`players/${playerId}/tagStats/${tag}/wrongCount`] = tagData.wrongCount + (isCorrect ? 0 : 1);
                }

                await database.ref().update(updates);
            }

            function checkAnswer(selectedIndex) {
                const buttons = answersElement.querySelectorAll(".answer-btn");
                buttons.forEach((btn, idx) => {
                    btn.disabled = true;
                    if (currentQuestion.shuffledAnswers[idx].isCorrect) {
                        btn.classList.add("correct");
                    } else if (idx === selectedIndex && !currentQuestion.shuffledAnswers[idx].isCorrect) {
                        btn.classList.add("wrong");
                        mistakes.push({
                            question: currentQuestion.question,
                            selected: currentQuestion.shuffledAnswers[selectedIndex].text,
                            correct: currentQuestion.shuffledAnswers.find(a => a.isCorrect).text,
                            tags: currentQuestion.tags || []
                        });
                        const delay = Math.floor(Math.random() * 3);
                        mistakenQuestions.push({ question: currentQuestion, delay });
                    }
                });
                const questionNumber = correctCount + wrongCount + 1;
                const isCorrect = currentQuestion.shuffledAnswers[selectedIndex].isCorrect;
                if (isCorrect) {
                    correctCount++;
                    currentStreak++;
                    longestStreak = Math.max(longestStreak, currentStreak);
                    answerSequence.push({ number: questionNumber, correct: true });
                    answeredCorrectly.push(currentQuestion);
                } else {
                    wrongCount++;
                    currentStreak = 0;
                    answerSequence.push({ number: questionNumber, correct: false });
                }
                updatePlayerStats(playerId, currentQuestion, isCorrect);
                updatePercentage();
                setTimeout(() => loadQuestion(), 1000);
            }

            function updateSequence() {
                sequenceContainer.innerHTML = "";
                const recentAnswers = answerSequence.slice(-4);
                const currentQuestionNumber = correctCount + wrongCount + 1;
                const displayedQuestions = [];

                recentAnswers.forEach((answer) => {
                    displayedQuestions.push({
                        number: answer.number,
                        correct: answer.correct,
                    });
                });

                displayedQuestions.push({
                    number: currentQuestionNumber,
                    correct: null,
                });

                while (displayedQuestions.length < 5) {
                    displayedQuestions.push({
                        number: currentQuestionNumber + (displayedQuestions.length - recentAnswers.length),
                        correct: null,
                    });
                }

                displayedQuestions.slice(0, 5).forEach((answer) => {
                    const circle = document.createElement("div");
                    circle.classList.add("sequence-circle");
                    circle.textContent = answer.number;
                    if (answer.number === currentQuestionNumber) {
                        circle.classList.add("current");
                    } else if (answer.correct === true) {
                        circle.classList.add("correct");
                    } else if (answer.correct === false) {
                        circle.classList.add("wrong");
                    }
                    sequenceContainer.appendChild(circle);
                });
            }

            function updatePercentage() {
                const total = correctCount + wrongCount;
                const percentage = total === 0 ? 0 : Math.round((correctCount / total) * 100);
                percentageCircle.textContent = `${percentage}%`;
            }

            function startTimer() {
                timer = 120;
                totalTime = 120;
                timerText.textContent = timer;
                updateTimerCircle();
                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timer--;
                    timerText.textContent = timer;
                    updateTimerCircle();
                    if (timer <= 30) {
                        timerProgress.style.stroke = "#ff0000";
                        if (timer % 3 === 0 && timer !== lastVibrationTime) {
                            vibrate(200);
                            lastVibrationTime = timer;
                        }
                    } else {
                        timerProgress.style.stroke = "#4299e1";
                    }
                    if (timer <= 0) {
                        endGame();
                    }
                }, 1000);
            }

            function updateTimerCircle() {
                const circumference = 159.84;
                const offset = circumference * (1 - timer / totalTime);
                timerProgress.style.strokeDashoffset = offset;
            }

            function launchConfetti() {
                const duration = 3000;
                const particleCount = Math.min(correctCount * 20, 200);
                const origins = Math.min(Math.floor((correctCount + wrongCount) / 5), 4);

                const defaults = {
                    startVelocity: 30,
                    spread: 360,
                    ticks: 60,
                    zIndex: 1000,
                };
                const config = { particleCount, duration };

                if (origins >= 1) confetti(Object.assign({}, defaults, { origin: { x: 0.2, y: 0.7 }, ...config }));
                if (origins >= 2) confetti(Object.assign({}, defaults, { origin: { x: 0.8, y: 0.7 }, ...config }));
                if (origins >= 3) confetti(Object.assign({}, defaults, { origin: { x: 0.4, y: 0.3 }, ...config }));
                if (origins >= 4) confetti(Object.assign({}, defaults, { origin: { x: 0.6, y: 0.3 }, ...config }));
            }

            async function endGame() {
                clearInterval(timerInterval);
                gameScreen.style.display = "none";
                resultScreen.style.display = "block";

                saveGameResult();

                const totalQuestions = correctCount + wrongCount;
                const percentage = totalQuestions === 0 ? 0 : Math.round((correctCount / totalQuestions) * 100);
                const avgTime = totalQuestions === 0 ? 0 : Math.round(totalTime / totalQuestions);
                document.getElementById("score").innerHTML = `
                    ×ª×©×•×‘×•×ª × ×›×•× ×•×ª: <span class="highlight">${correctCount}</span> | ×ª×©×•×‘×•×ª ×©×’×•×™×•×ª: ${wrongCount}<br>
                    ×–××Ÿ ×××•×¦×¢ ×œ×©××œ×”: ${avgTime} ×©× ×™×•×ª | ×¨×¦×£ ×”×›×™ ××¨×•×š: ${longestStreak}
                `;

                const progressCircle = document.getElementById("progress-circle");
                const circumference = 157;
                const offset = circumference * (1 - percentage / 100);
                progressCircle.style.strokeDashoffset = offset;
                let count = 0;
                const percentageAnim = setInterval(() => {
                    if (count <= percentage) {
                        document.getElementById("percentage-text").textContent = `${count}%`;
                        count++;
                    } else {
                        clearInterval(percentageAnim);
                    }
                }, 20);

                let toolsText = "×›×œ×™× ×‘×©×™××•×©: ";
                toolsText += fiftyFiftyUsed ? "50:50, " : "";
                toolsText += addTimeUsed ? "30+, " : "";
                toolsText += skipUsed > 0 ? `×“×™×œ×’×ª ${skipUsed} ×¤×¢××™×, ` : "";
                toolsText = toolsText.endsWith(", ") ? toolsText.slice(0, -2) : toolsText;
                toolsText = toolsText === "×›×œ×™× ×‘×©×™××•×©: " ? "×œ× × ×¢×©×” ×©×™××•×© ×‘×›×œ×™×" : toolsText;
                toolsUsedElement.textContent = toolsText;

                const rankings = await getDailyRankings();
                document.getElementById("ranking").innerHTML = `
                    <p>××§×•× ${rankings.rankCorrect} ××ª×•×š ${rankings.totalPlayers} ×©×—×§× ×™×</p>
                    <p>×ª×©×•×‘×•×ª × ×›×•× ×•×ª: ${correctCount} (×©×™× ×™×•××™: ${rankings.topCorrect})</p>
                    <p>×¨×¦×£ ×©×™×: ${longestStreak} (×©×™× ×™×•××™: ${rankings.topStreak})</p>
                `;

                if (mistakes.length > 0) {
                    mistakesElement.innerHTML = "";
                    const uniqueMistakes = new Map();
                    mistakes.forEach((mistake) => uniqueMistakes.set(mistake.question, mistake));
                    uniqueMistakes.forEach((mistake) => {
                        mistakesElement.innerHTML += `
                            <div class="mistake-block">
                                <div class="mistake-question">${mistake.question}</div>
                                <div class="wrong-answer">âŒ ${mistake.selected}</div>
                                <div class="correct-answer">âœ… ${mistake.correct}</div>
                                <div class="tip">ğŸ’¡ ×˜×™×¤: ×‘×“×•×§ ××ª ×”× ×•×©× ×©×•×‘ ×œ×§×¨××ª ×”×‘×’×¨×•×ª!</div>
                            </div>
                        `;
                    });
                } else {
                    mistakesElement.innerHTML = totalQuestions > 0 ? '<p class="perfect">××•×©×œ×! ××ª×” ××•×›×Ÿ ×œ×‘×’×¨×•×ª!</p>' : '<p>×œ× ×¢× ×™×ª ×¢×œ ××£ ×©××œ×” ×”×¤×¢×...</p>';
                }

                const tagStatsSnapshot = await database.ref(`players/${playerId}/tagStats`).once('value');
                const tagStats = tagStatsSnapshot.val() || {};
                const tagCloud = Object.entries(tagStats).map(([tag, stats]) => {
                    const total = stats.correctCount + stats.wrongCount;
                    const accuracy = total === 0 ? 0 : (stats.correctCount / total) * 100;
                    let color = accuracy > 75 ? '#48bb78' : accuracy > 25 ? '#ecc94b' : '#f56565';
                    let size = Math.min(16 + total * 2, 36);
                    return { tag, accuracy, color, size, correct: stats.correctCount, wrong: stats.wrongCount };
                });

                tagAnalysisElement.innerHTML = "";
                tagCloud.forEach(item => {
                    const tagElement = document.createElement("span");
                    tagElement.classList.add("tag-cloud-item");
                    tagElement.style.color = item.color;
                    tagElement.style.fontSize = `${item.size}px`;
                    tagElement.textContent = `${item.tag} (${item.correct}/${item.correct + item.wrong}) `;
                    tagElement.title = `×“×™×•×§: ${Math.round(item.accuracy)}%`;
                    tagAnalysisElement.appendChild(tagElement);
                });

                document.getElementById("share-result").addEventListener("click", () => {
                    vibrate(50);
                    const shareText = `× ×™×¦×—×ª×™ ×‘×˜×¨×™×•×•BIO ×¢× ${correctCount} ×ª×©×•×‘×•×ª × ×›×•× ×•×ª ×•×¨×¦×£ ×©×œ ${longestStreak}! ğŸ‰`;
                    if (navigator.share) {
                        navigator.share({
                            title: "×ª×•×¦××” ×‘×˜×¨×™×•×•BIO",
                            text: shareText,
                            url: window.location.href,
                        }).catch((err) => console.error("×©×’×™××” ×‘×©×™×ª×•×£:", err));
                    } else {
                        navigator.clipboard.writeText(shareText).then(() => showToast("×”×ª×•×¦××” ×”×•×¢×ª×§×” ×œ×œ×•×—!"));
                    }
                });

                launchConfetti();
            }
        }
    </script>
</body>
</html>